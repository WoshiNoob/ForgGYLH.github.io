{"meta":{"title":"我们都有光明的前途","subtitle":"一只数论自闭字符串不会的菜狗","description":"Hachi赛高","author":"FrogG_YLH.","url":"https//:ForgGYLH.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-31T10:44:01.000Z","updated":"2019-11-03T12:44:40.135Z","comments":true,"path":"categories/index.html","permalink":"https//:ForgGYLH.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-31T10:43:52.000Z","updated":"2019-11-03T12:45:59.743Z","comments":true,"path":"tags/index.html","permalink":"https//:ForgGYLH.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CF1271E-Common Number","slug":"CF1271E-Common Nunber","date":"2019-12-17T09:51:39.000Z","updated":"2019-12-17T01:44:52.859Z","comments":true,"path":"2019/12/17/CF1271E-Common Nunber/","link":"","permalink":"https//:ForgGYLH.github.io/2019/12/17/CF1271E-Common%20Nunber/","excerpt":"","text":"这道题，一开始以为是什么牛逼的数学题 后来发现好像答案满足单调性？？ 于是二分check就完事了 稳妥一点就分奇偶分别check 像我就喜欢骚一点 直接一遍check 复杂度O(logn^2) 快的一批 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;ll n,k;int ok(ll x)&#123; ll cnt=1;ll l=x,r=x; if(x%2==0&amp;&amp;x&lt;n)&#123; cnt++;r++; &#125; while(1)&#123; ll l1=l*2,r1=r*2+1; if(r1&gt;n)&#123; if(l1&gt;n)&#123; return cnt&gt;=k; &#125; return (cnt+n-l1+1)&gt;=k; &#125; cnt+=r1-l1+1;r=r1;l=l1; &#125; &#125;ll bs(ll l,ll r)&#123; ll ans=l; while(l&lt;=r)&#123; ll mid=(l+r)/2; if(mid%2&amp;&amp;mid+1&lt;=r)&#123; mid+=1; &#125; if(ok(mid))&#123; ans=mid; l=mid+1; &#125;else&#123; r=mid-1; &#125; &#125; return ans;&#125;int main()&#123; scanf(\"%lld%lld\",&amp;n,&amp;k); printf(\"%lld\\n\",bs(1,n));&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1271E-Common Number","slug":"CF1271E-Common Number","date":"2019-12-17T09:51:39.000Z","updated":"2019-12-17T01:44:26.631Z","comments":true,"path":"2019/12/17/CF1271E-Common Number/","link":"","permalink":"https//:ForgGYLH.github.io/2019/12/17/CF1271E-Common%20Number/","excerpt":"","text":"这道题，一开始以为是什么牛逼的数学题 后来发现好像答案满足单调性？？ 于是二分check就完事了 稳妥一点就分奇偶分别check 像我就喜欢骚一点 直接一遍check 复杂度O(logn^2) 快的一批 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;ll n,k;int ok(ll x)&#123; ll cnt=1;ll l=x,r=x; if(x%2==0&amp;&amp;x&lt;n)&#123; cnt++;r++; &#125; while(1)&#123; ll l1=l*2,r1=r*2+1; if(r1&gt;n)&#123; if(l1&gt;n)&#123; return cnt&gt;=k; &#125; return (cnt+n-l1+1)&gt;=k; &#125; cnt+=r1-l1+1;r=r1;l=l1; &#125; &#125;ll bs(ll l,ll r)&#123; ll ans=l; while(l&lt;=r)&#123; ll mid=(l+r)/2; if(mid%2&amp;&amp;mid+1&lt;=r)&#123; mid+=1; &#125; if(ok(mid))&#123; ans=mid; l=mid+1; &#125;else&#123; r=mid-1; &#125; &#125; return ans;&#125;int main()&#123; scanf(\"%lld%lld\",&amp;n,&amp;k); printf(\"%lld\\n\",bs(1,n));&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"2019广工新生赛sabee题解","slug":"2019广工新生赛sabee题解","date":"2019-12-10T09:51:39.000Z","updated":"2019-12-10T12:05:18.304Z","comments":true,"path":"2019/12/10/2019广工新生赛sabee题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/12/10/2019%E5%B9%BF%E5%B7%A5%E6%96%B0%E7%94%9F%E8%B5%9Bsabee%E9%A2%98%E8%A7%A3/","excerpt":"","text":"suibianxiexie A-原初的信纸 题目链接 签到成功，这是你的签到奖励.jpg 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;int a[maxn];void solve()&#123; int n;scanf(\"%d\",&amp;n);int mx=0; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); mx=max(mx,a[i]); &#125; printf(\"%d\\n\",mx);&#125;int main()&#123; int t;scanf(\"%d\",&amp;t);while(t--)&#123; solve(); &#125;&#125; tags: *500 B-骑士的对决 题目链接 签到成功，这是你的签到奖励.jpg 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;int main()&#123; char a,b,c,d; scanf(\"%c%c%c%c\",&amp;a,&amp;b,&amp;c,&amp;d); if(d=='S'&amp;&amp;a=='S'&amp;&amp;b=='J'||d=='S'&amp;&amp;a=='J'&amp;&amp;b=='S'||d=='J'&amp;&amp;a=='B'&amp;&amp;b=='J'||d=='J'&amp;&amp;a=='J'&amp;&amp;b=='B'||d=='B'&amp;&amp;a=='B'&amp;&amp;b=='S'||d=='B'&amp;&amp;a=='S'&amp;&amp;b=='B')&#123; printf(\"lyrnb\"); &#125;else&#123; printf(\"pmznb\"); &#125;&#125; tags: game *600 C-秘密的议会 题目链接 签到成功，这是你的签到奖励.jpg 1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;void solve()&#123; char ch[110]; scanf(\"%s\",ch); int n=strlen(ch); int cnt1=0;int cnt2=0; for(int i=0;i&lt;n;i++)&#123; if(ch[i]=='Y'||ch[i]=='y')&#123; cnt1++; &#125;else if(ch[i]=='N'||ch[i]=='n')&#123; cnt2++; &#125; &#125; if(cnt1&gt;=n/2)&#123; printf(\"pmznb\\n\"); &#125;else if(cnt2&gt;=n/2)&#123; printf(\"lyrnb\\n\"); &#125;else printf(\"wsdd\\n\");&#125;int main()&#123; int t;scanf(\"%d\",&amp;t); while(t--) solve();&#125; tags: *600 D-城市的税金 题目链接 按题意模拟即可 1234567891011121314151617181920212223242526272829303132#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;ll a[maxn];int n,m;ll fun(ll x)&#123; return x*251%996*404*123;&#125; map&lt;ll,int&gt;mp;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;a[i]); &#125; while(m--)&#123; ll op,b,c; scanf(\"%lld%lld%lld\",&amp;op,&amp;b,&amp;c); if(op==1)&#123; for(int i=b;i&lt;=c;i++)&#123; a[i]=fun(a[i]); &#125; &#125;else&#123; mp.clear();int ans=0; for(int i=b;i&lt;=c;i++)&#123; mp[a[i]]++; ans=max(ans,mp[a[i]]); &#125; printf(\"%d\\n\",ans); &#125; &#125;&#125; tags: implementation data strcutres *700 E-缺席的神官 题目链接 基础贪心，将工作日之间的间隔加入优先队列，取前k个即可。 123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;ll a[maxn];int n,m,k;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); sort(a+1,a+n+1); int sum=a[n]-a[1]+1; priority_queue&lt;int&gt;q; for(int i=1;i&lt;n;i++)&#123; q.push(a[i+1]-a[i]-1); &#125; k--; while(k--)&#123; sum-=q.top();q.pop(); &#125; printf(\"%d\\n\",sum);&#125; tags: greedy *1000 F-失踪的玫瑰 题目链接 待补 tags:math *2200 G-虚数的纸牌 题目链接 sb模拟题，按题意模拟即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int f1(int x)&#123; if(x==4) return 6; if(x==3) return 3; if(x==2) return 1;&#125;int f2(int x)&#123; if(x==4) return 4; return 1;&#125;char ch[20];int cnt[15];void solve()&#123; scanf(\"%s\",ch); memset(cnt,0,sizeof(cnt)); int n=strlen(ch); for(int i=0;i&lt;n;i++)&#123; if(ch[i]&gt;='3'&amp;&amp;ch[i]&lt;='9')&#123; cnt[ch[i]-'3']++; &#125;else if(ch[i]=='0') cnt[7]++; else if(ch[i]=='A') cnt[11]++; else if(ch[i]=='2') cnt[12]++; else if(ch[i]=='J') cnt[8]++; else if(ch[i]=='Q') cnt[9]++; else if(ch[i]=='K') cnt[10]++; &#125; int ans=17; for(int i=0;i&lt;=12;i++)&#123; if(cnt[i]&gt;=2)&#123; ans+=f1(cnt[i]); &#125;if(cnt[i]&gt;=3)&#123; ans+=f2(cnt[i])*(17-cnt[i]); int res=0; for(int j=0;j&lt;=12;j++)&#123; if(i==j) continue; if(cnt[j]&gt;=2)&#123; res+=f1(cnt[j]); &#125; &#125; ans+=res*f2(cnt[i]); &#125;if(cnt[i]==4)&#123; ans++; &#125; &#125; for(int i=0;i&lt;=8;i++)&#123; if(cnt[i]&amp;&amp;cnt[i+1]&amp;&amp;cnt[i+2]&amp;&amp;cnt[i+3]&amp;&amp;cnt[i+4])&#123; ans+=cnt[i]*cnt[i+1]*cnt[i+2]*cnt[i+3]*cnt[i+4]; &#125; &#125; printf(\"%d\\n\",ans);&#125;int main()&#123; int t;scanf(\"%d\",&amp;t);while(t--) solve();&#125; tags: implementation *1000 H-绵羊的硬币 题目链接 打个表 天才wz嘴了正解 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;ll fib[110]; void solve()&#123; ll n;scanf(\"%lld\",&amp;n); ll now=1;int cnt=0; for(int i=0;i&lt;=60;i++)&#123; if(now&gt;n)&#123; break; &#125; now*=2;cnt++; &#125; printf(\"%lld\\n\",fib[cnt]);&#125;int main()&#123; fib[1]=1;fib[2]=1; for(int i=3;i&lt;=100;i++)&#123; fib[i]=fib[i-1]+fib[i-2]; &#125;int t;scanf(\"%d\",&amp;t);while(t--) solve();&#125; tags: math,brute force,*1300 I-迷途的怪物 题目链接 找规律，当n为奇数时答案为1，n为偶数时答案为p-1;就是这么简单 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;ll p;char n[1000010];void solve()&#123; scanf(\"%lld%s\",&amp;p,n); int len=strlen(n); int ok=n[len-1]-'0'; if(ok%2==0)&#123; printf(\"1\\n\"); &#125;else&#123; printf(\"%lld\\n\",p-1); &#125;&#125;int main()&#123; int t;scanf(\"%d\",&amp;t);while(t--) solve();&#125; tags: math,brute force,*1500 J-简单的数学 题目链接 简单数学题（不是 只要你认真求导 发现当x=1代进去 能消掉一大片233. 代码又是傻逼几行 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;void solve()&#123; ll n;scanf(\"%lld\",&amp;n); if(n%2==0) printf(\"-%lld\\n\",n*(n+1)); else printf(\"%lld\\n\",n*(n+1));&#125;int main()&#123; int t;scanf(\"%d\",&amp;t);while(t--)&#123; solve(); &#125;&#125; tags: math,*1300 K-消亡的质数 题目链接 被天才wz嘲笑了两天 自闭了 傻逼题 但我更sb 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;void solve()&#123; ll n;scanf(\"%lld\",&amp;n); n--;if(n%3)&#123; printf(\"NO\\n\");return ; &#125; n/=3;ll p=sqrt(n);if(p*(p+1)==n) printf(\"YES\\n\"); else printf(\"NO\\n\");&#125;int main()&#123; int t;scanf(\"%d\",&amp;t);while(t--)&#123; solve(); &#125;&#125; tags: math,*-1 L-危险的台阶 待补 tags:math, *2500 M-破碎的愿望 题目链接 为什么，明明是我最爱字符串题，为什么会变成这样。。。 写了1w年 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=2e5+50;char ch[40];int main()&#123; int n;ll k;scanf(\"%d%lld\",&amp;n,&amp;k); scanf(\"%s\",ch); ll x1=k/n;ll x2=k%n; if(x2) x1++; if(x1%2==0) reverse(ch,ch+n); x2=(k-1)%n; printf(\"%c\",ch[x2]); &#125; tags:strings *500","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces图论刷题之路 2-1245D. Shichikuji and Power Grid","slug":"graph2","date":"2019-11-09T07:49:22.000Z","updated":"2019-11-09T07:57:33.705Z","comments":true,"path":"2019/11/09/graph2/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/09/graph2/","excerpt":"一道看似很牛逼实际上很sb的最小生成树，绝了。","text":"一道看似很牛逼实际上很sb的最小生成树，绝了。 先对原图建立一个完全图，边权如题所示，再建立一个虚拟源点，每个点和源点都连一条边，权值为建造这个点为发电站的值。然后跑最小生成树。。。艹，这也太sb了。 时间复杂度 O(N2)； 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxe=4e6+50;const int maxn=2050;struct node&#123; int s,t; ll val;&#125;edge[maxe],ans0[maxn],ans1[maxn];int bel[maxn];int vis[maxn];ll x[maxn],y[maxn],cost[maxn];int cnt,n,res0,res1;int cmp(node a,node b)&#123; return a.val&lt;b.val;&#125;int find(int x)&#123; if(bel[x]!=x)&#123; return bel[x]=find(bel[x]); &#125; return x;&#125;void merge(int x,int y)&#123; int fx=find(x); int fy=find(y); if(fx!=fy)&#123; bel[max(fx,fy)]=min(fx,fy); &#125;&#125;void init()&#123; for(int i=0;i&lt;=n;i++)&#123; vis[i]=0; bel[i]=i; &#125; cnt=0;res0=0;res1=0;&#125;void add(int a,int b,ll c)&#123; edge[cnt].s=a; edge[cnt].t=b; edge[cnt++].val=c;&#125;ll kruskal()&#123; ll ans=0; int count=0; sort(edge,edge+cnt,cmp); for(int i=0;i&lt;cnt;i++)&#123; if(find(edge[i].s)!=find(edge[i].t))&#123; ans+=edge[i].val; merge(edge[i].s,edge[i].t); count++; if(edge[i].s==0||edge[i].t==0) ans0[++res0]=edge[i]; else ans1[++res1]=edge[i]; &#125; if(count==n) break; &#125; return ans;&#125;int main()&#123; scanf(\"%d\",&amp;n); init(); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld%lld\",&amp;x[i],&amp;y[i]); &#125;for(int i=1;i&lt;=n;i++)&#123; ll x;scanf(\"%lld\",&amp;x); add(0,i,x); &#125;for(int i=1;i&lt;=n;i++)&#123; scanf(\"%lld\",&amp;cost[i]); for(int j=1;j&lt;i;j++)&#123; ll c=abs(x[i]-x[j])+abs(y[i]-y[j]); c*=(cost[i]+cost[j]); add(i,j,c); &#125; &#125; printf(\"%lld\\n\",kruskal()); printf(\"%d\\n\",res0); for(int i=1;i&lt;=res0;i++)&#123; printf(\"%d \",max(ans0[i].s,ans0[i].t)); &#125;printf(\"\\n%d\\n\",res1); for(int i=1;i&lt;=res1;i++)&#123; printf(\"%d %d\\n\",ans1[i].s,ans1[i].t); &#125;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces图论刷题之路 1-1243D. 0-1 MST","slug":"CFGraphs","date":"2019-11-09T07:36:01.000Z","updated":"2019-11-09T07:46:04.674Z","comments":true,"path":"2019/11/09/CFGraphs/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/09/CFGraphs/","excerpt":"发现自己图论菜的一 所以开始疯狂刷图论题。这是一道看似最小生成树实则是求补图连通块个数的题。","text":"发现自己图论菜的一 所以开始疯狂刷图论题。这是一道看似最小生成树实则是求补图连通块个数的题。 如何求连通块的个数：对每一个节点，如果他没有被讨论过，即vis[i]=0,则对它进行讨论：将那些剩下未讨论的节点逐个遍历，若他们之间没有权值为1的边相连，则说明在补图中他们是连通的，于是将他们归为一个集合，并从未讨论的集合中删除，这样从1到n逐个遍历。复杂度为（n+m）logn，因为看似是先for一遍再在每个i中再for一遍，可由于边也只有1e5条，所以均摊下来复杂度是成立的。 其中 未讨论的集合我放到了set中，已经讨论过就打上vis标记并从v中删除，每一次讨论用dfs将之后能够加入到这个连通块中的点一并加入，这样就不用并查集最后再遍历一遍数个数了。 QAQ。。。。 时间：140ms 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int maxn=1e5+50;const int INF = 1e9;set&lt;int&gt;g[maxn];set&lt;int&gt;v;int vis[maxn];void dfs(int x)&#123; vis[x]=1; vector&lt;int&gt;tmp; for(int i:v)&#123; if(!g[x].count(i))&#123; tmp.push_back(i); &#125; &#125; for(int i:tmp)&#123; v.erase(i); &#125; for(int i:tmp)&#123; dfs(i); &#125;&#125;int main()&#123; int n,m; scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int a,b; scanf(\"%d%d\",&amp;a,&amp;b); g[a].insert(b);g[b].insert(a); &#125; for(int i=1;i&lt;=n;i++)&#123; v.insert(i); &#125; //memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) vis[i]=0;int ans=0; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; ans++; v.erase(i); dfs(i); &#125; &#125; printf(\"%d\\n\",ans-1);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1256b-MinimizethePermutation题解","slug":"CF1256b-MinimizethePermutation题解","date":"2019-11-05T13:11:55.000Z","updated":"2019-11-05T13:11:55.433Z","comments":true,"path":"2019/11/05/CF1256b-MinimizethePermutation题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/05/CF1256b-MinimizethePermutation%E9%A2%98%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"CF1256B-Minimize the Permutation题解","slug":"CF1256b-Minimize the Permutation题解","date":"2019-11-05T13:11:55.000Z","updated":"2019-11-05T13:23:46.967Z","comments":true,"path":"2019/11/05/CF1256b-Minimize the Permutation题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/05/CF1256b-Minimize%20the%20Permutation%E9%A2%98%E8%A7%A3/","excerpt":"这道题。。比赛时候甚至写炸了 555 我太菜了","text":"这道题。。比赛时候甚至写炸了 555 我太菜了 题解：因为每个交换只能用一次 而且数据范围贼小 直接n2暴力即可 方法：从1枚举到N 当枚举到一个i时 贪心地把i往前移动，如果当前所在位置的移动机会已经用掉或者前面一个数比当前的数要小 则停止移动 n2是因为我懒得写VIS数组了。。直接暴力找 on的解法也很容易写 上代码 n2 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=110+50;typedef long long ll;int a[maxn];int vis[maxn];int main()&#123; int t,n; scanf(\"%d\",&amp;t); while(t--)&#123; memset(vis,0,sizeof(vis)); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; int now; for(int j=1;j&lt;=n;j++)&#123; if(a[j]==i)&#123; now=j;break; &#125; &#125; for(int j=now;j&gt;=2;j--)&#123; if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1])&#123; swap(a[j],a[j-1]); vis[j-1]=1; &#125;else&#123; break; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); &#125;&#125; on 加了个pos数组存储位置 实时更新 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=110+50;typedef long long ll;int a[maxn];int vis[maxn];int pos[maxn];int main()&#123; int t,n; scanf(\"%d\",&amp;t); while(t--)&#123; memset(vis,0,sizeof(vis)); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); pos[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; int now=pos[i]; for(int j=now;j&gt;=2;j--)&#123; if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1])&#123; swap(pos[a[j]],pos[a[j-1]]); swap(a[j],a[j-1]); vis[j-1]=1; &#125;else&#123; break; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); &#125;&#125; 。。多练吧QAQ","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"LuoGuP1470【最长前缀LongestPrefix】","slug":"LuoGuP1470【最长前缀LongestPrefix】","date":"2019-11-04T09:54:20.000Z","updated":"2019-11-05T04:11:11.060Z","comments":true,"path":"2019/11/04/LuoGuP1470【最长前缀LongestPrefix】/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/LuoGuP1470%E3%80%90%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80LongestPrefix%E3%80%91/","excerpt":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。","text":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。 上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn=5050;const int INF = 0x3f3f3f3f;int tree[maxn][30];bool vis[2020][200020];int ed[maxn];char que[200020];char ch[20];int n,cnt,Len;int ans=0;int newnode()&#123; for(int i=0;i&lt;=26;i++)&#123; tree[cnt][i]=-1; &#125; ed[cnt]=0; return cnt++;&#125;void init()&#123; cnt=0; newnode();&#125;void insert()&#123; int len=strlen(ch); int root=0; for(int i=0;i&lt;len;i++)&#123; int x=ch[i]-'A'; if(tree[root][x]&lt;=0)&#123; tree[root][x]=newnode(); &#125; root=tree[root][x]; &#125; ed[root]=1;&#125;void dfs(int pos,int len)&#123; if(vis[pos][len]) return; vis[pos][len]=1; int x=que[len]-'A'; if(ed[pos])&#123; ans=max(ans,len); &#125; if(len==Len)&#123; return; &#125; if(tree[pos][x]!=-1)&#123; dfs(tree[pos][x],len+1); &#125;if(ed[pos])&#123; dfs(0,len); &#125;&#125;int main()&#123; init(); while(scanf(\"%s\",ch)&amp;&amp;strcmp(ch,\".\"))&#123; insert(); &#125; Len=0; while(scanf(\"%s\",que+Len)!=EOF)&#123; Len=strlen(que); &#125; dfs(0,0); printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"我来辣-ToDoList","slug":"我来辣-ToDoList","date":"2019-11-04T09:51:39.000Z","updated":"2019-11-20T01:17:12.028Z","comments":true,"path":"2019/11/04/我来辣-ToDoList/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/%E6%88%91%E6%9D%A5%E8%BE%A3-ToDoList/","excerpt":"断断续续搞了两三天，终于是完工了，可以开始写博客了。","text":"断断续续搞了两三天，终于是完工了，可以开始写博客了。 第一篇博客 总要定一点远大的理想 那下面就是ToDoList：1.染个头发+买个显示器2.上个紫名3.学点图论 搞点数论字符串4.经常更博5.一等奖学金6.校赛天梯赛一血前耻7.拿到参加省赛的机会8.拿到尽可能多的参赛机会 9.CCPC ICPC 银牌暂时先列这么多….有想法再补 FrogG冲冲冲!想一下接下来要学习和巩固的算法 图论：最短路dij 网络流相关 数据结构：线段树 平衡树 DP 搜索相关 杂项：差分约束 2-sat 位运算相关 分治 数论相关。。。 字符串：后缀数组 定个小目标 扫荡1900分以下的题","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https//:ForgGYLH.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]}