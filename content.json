{"meta":{"title":"进来坐坐呗~","subtitle":"一只数论自闭字符串不会的菜狗","description":"Hachi赛高","author":"FrogG_YLH.","url":"https//:ForgGYLH.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-10-31T10:43:52.000Z","updated":"2019-11-03T12:45:59.743Z","comments":true,"path":"tags/index.html","permalink":"https//:ForgGYLH.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-31T10:44:01.000Z","updated":"2019-11-03T12:44:40.135Z","comments":true,"path":"categories/index.html","permalink":"https//:ForgGYLH.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"LuoGuP1470【最长前缀LongestPrefix】","slug":"LuoGuP1470【最长前缀LongestPrefix】","date":"2019-11-04T09:54:20.000Z","updated":"2019-11-05T04:11:11.060Z","comments":true,"path":"2019/11/04/LuoGuP1470【最长前缀LongestPrefix】/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/LuoGuP1470%E3%80%90%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80LongestPrefix%E3%80%91/","excerpt":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。","text":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。 上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn=5050;const int INF = 0x3f3f3f3f;int tree[maxn][30];bool vis[2020][200020];int ed[maxn];char que[200020];char ch[20];int n,cnt,Len;int ans=0;int newnode()&#123; for(int i=0;i&lt;=26;i++)&#123; tree[cnt][i]=-1; &#125; ed[cnt]=0; return cnt++;&#125;void init()&#123; cnt=0; newnode();&#125;void insert()&#123; int len=strlen(ch); int root=0; for(int i=0;i&lt;len;i++)&#123; int x=ch[i]-'A'; if(tree[root][x]&lt;=0)&#123; tree[root][x]=newnode(); &#125; root=tree[root][x]; &#125; ed[root]=1;&#125;void dfs(int pos,int len)&#123; if(vis[pos][len]) return; vis[pos][len]=1; int x=que[len]-'A'; if(ed[pos])&#123; ans=max(ans,len); &#125; if(len==Len)&#123; return; &#125; if(tree[pos][x]!=-1)&#123; dfs(tree[pos][x],len+1); &#125;if(ed[pos])&#123; dfs(0,len); &#125;&#125;int main()&#123; init(); while(scanf(\"%s\",ch)&amp;&amp;strcmp(ch,\".\"))&#123; insert(); &#125; Len=0; while(scanf(\"%s\",que+Len)!=EOF)&#123; Len=strlen(que); &#125; dfs(0,0); printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"我来辣-ToDoList","slug":"我来辣-ToDoList","date":"2019-11-04T09:51:39.000Z","updated":"2019-11-04T09:52:44.103Z","comments":true,"path":"2019/11/04/我来辣-ToDoList/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/%E6%88%91%E6%9D%A5%E8%BE%A3-ToDoList/","excerpt":"断断续续搞了两三天，终于是完工了，可以开始写博客了。","text":"断断续续搞了两三天，终于是完工了，可以开始写博客了。 第一篇博客 总要定一点远大的理想 那下面就是ToDoList：1.染个头发+买个显示器2.上个紫名3.学点图论 搞点数论字符串4.经常更博5.一等奖学金6.校赛天梯赛一血前耻7.拿到参加省赛的机会8.拿到尽可能多的参赛机会9.CCPC ICPC 银牌 暂时先列这么多….有想法再补 FrogG冲冲冲!","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https//:ForgGYLH.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]}