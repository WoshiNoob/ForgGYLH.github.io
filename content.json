{"meta":{"title":"我们都有光明的前途","subtitle":"想拿金牌想上红名","description":"Hachi赛高","author":"西瓜喵喵.","url":"https//:ForgGYLH.github.io","root":"/"},"pages":[{"title":"links","date":"2013-07-13T12:46:25.000Z","updated":"2020-03-08T09:26:20.421Z","comments":true,"path":"PY.html","permalink":"https//:ForgGYLH.github.io/PY.html","excerpt":"","text":"友情链接wenzhuan 转转我宝贝 ovo willingox 刘老师 K0u1e 阿燕 codgician zsj学长 axiomofchoice hjt永远滴神 Edwiv 郑老师 UniverseofHK jxl ILLLZKQF 施老师 jiedai 小汤"},{"title":"categories","date":"2019-10-31T10:44:01.000Z","updated":"2019-11-03T12:44:40.135Z","comments":true,"path":"categories/index.html","permalink":"https//:ForgGYLH.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-31T10:43:52.000Z","updated":"2019-11-03T12:45:59.743Z","comments":true,"path":"tags/index.html","permalink":"https//:ForgGYLH.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Codeforces Round","slug":"cf616","date":"2020-03-11T09:51:39.000Z","updated":"2020-03-11T04:48:59.054Z","comments":true,"path":"2020/03/11/cf616/","link":"","permalink":"https//:ForgGYLH.github.io/2020/03/11/cf616/","excerpt":"好久没更了，更一场上了大分的div2 赛时rk18 +168（呜呜当时怎么这么猛） 传送门","text":"好久没更了，更一场上了大分的div2 赛时rk18 +168（呜呜当时怎么这么猛） 传送门 整体难度 A&lt;B&lt;C&lt;D&lt;F&lt;E A. Even But Not Even可能是全场写的最煎熬的题了(按题意模拟写的) 赛后知道只要输出两个奇数就好了 艹 我的sb代码 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; char ch[3030]; void solve(){ int n;scanf(&quot;%d%s&quot;,&amp;n,ch);int sum=0;int cnt=-1; for(int i=0;i&lt;n;i++){ sum+=ch[i]-&#39;0&#39;; if((ch[i]-&#39;0&#39;)%2) cnt=i; }if(sum%2==0&amp;&amp;(ch[n-1]-&#39;0&#39;)%2){ printf(&quot;%s\\n&quot;,ch);return; } if(n==1||cnt==-1){ printf(&quot;-1\\n&quot;); return; }sum=0;int flag=-1;for(int i=0;i&lt;=cnt;i++){ sum+=ch[i]-&#39;0&#39;;if((ch[i]-&#39;0&#39;)%2&amp;&amp;i!=cnt) flag=i; }if(sum%2==0){ for(int i=0;i&lt;=cnt;i++) printf(&quot;%c&quot;,ch[i]);printf(&quot;\\n&quot;); }else if(flag==-1){ printf(&quot;-1\\n&quot;); }else{ for(int i=0;i&lt;=cnt;i++) if(i!=flag) printf(&quot;%c&quot;,ch[i]);printf(&quot;\\n&quot;); } } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } 实际上只需要这样 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=(int)2e5+100; int n; char s[maxn]; int solve(){ scanf(&quot;%d%s&quot;,&amp;n,s+1); int cnt=0,ans=0; for(int i=1;i&lt;=n;i++){ if((s[i]-&#39;0&#39;)%2) cnt++,ans=ans*10+s[i]-&#39;0&#39;; if(cnt==2) return printf(&quot;%d\\n&quot;,ans); }return puts(&quot;-1&quot;); } int main(){ int T;cin&gt;&gt;T;while(T--) solve(); } B. Array Sharpening这把我是弱智A题，但是没关系，因为我就要开启王者模式，芜湖起飞，从现在开始我要起飞了~ 不知道他们为啥写的这么慢 贪心想一想 满足最小的情况就行 正反dp一下 然后judge就好了 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=3e5+50; int a[maxn]; int ok1[maxn],ok2[maxn]; int solve(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),ok1[i]=ok2[i]=0;ok2[n+1]=1; for(int i=n;i&gt;=1;i--){ if(a[i]&gt;=n-i) ok2[i]=1; else break; }for(int i=1;i&lt;=n;i++){ if(a[i]&gt;=i-1) ok1[i]=1; else break; }for(int i=1;i&lt;=n;i++){ if(ok1[i]&amp;&amp;ok2[i]) return printf(&quot;Yes\\n&quot;); }return printf(&quot;No\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } C.Mind Control比较迷幻的一道题，看到3500就知道N2，然后既然要控制人，那我肯定一开始就要控制（但其实我也不知道为什么，单纯因为如果不是这样会非常难写，所以就开莽了），那么在这个基础上，枚举左边需要控制多少人，右边就是k-左边的人数，取最大值，这是第一重循环，然后的话再枚举左边随机的人，因为随机，所以肯定取最小值，这是第二重循环，那么答案其实已经出来了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; int a[3550]; void solve(){ int n,m,k;scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); k=min(k,m-1);int ans=0; for(int i=0;i&lt;=k;i++){ int l=i+1;int r=n-(k-i);int rem=m-k-1;int res=1e9; for(int j=0;j&lt;=rem;j++){ int l1=l+j;int r1=r-(rem-j); int tmp=max(a[l1],a[r1]);res=min(res,tmp); }ans=max(ans,res); }printf(&quot;%d\\n&quot;,ans); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } D.Irreducible Anagrams这波啊，这波是随便猜猜 给你一个串和q个询问，每个询问给定这个串中的子串，问你能否找出另一个串满足“at least one irreducible anagram.” q既然是1e5，那询问复杂度肯定不高，我就直接开始猜结论。 那么有三种情况是判yes的，其余都是no: 1.len为1（很简单，不证了 2.子串开头结尾不相等：那么只要把开头和结尾调换一下，中间复制，就是符合要求的串 3.有三个及以上不同的字母：建立在首尾相同的情况下，假设开头结尾字母为A，剩下两个为BC,我们用B替换开头的A，用C替换结尾的A，注意不能用第二个出现的字母去替换开头。 如：ABCA-&gt;CAAB 而不能AB|CA-&gt;BA|AC AAABCCCA-&gt;CAAAABCC #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; char ch[maxn];int cnt[maxn][30]; int solve(){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); int x=ch[r]-&#39;a&#39;; if(ch[l]!=ch[r]||l==r) return printf(&quot;Yes\\n&quot;); int ans=0; for(int i=0;i&lt;26;i++) if(cnt[r][i]-cnt[l][i]) ans++; if(ans&gt;=3) return printf(&quot;Yes\\n&quot;); else return printf(&quot;No\\n&quot;); } int main(){ scanf(&quot;%s&quot;,ch+1);int q;scanf(&quot;%d&quot;,&amp;q);int n=strlen(ch+1); for(int i=0;i&lt;26;i++) cnt[0][i]=0; for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;26;j++) cnt[i][j]=cnt[i-1][j]; cnt[i][ch[i]-&#39;a&#39;]++; }while(q--) solve(); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces Round 615(Div.3)","slug":"CodeForces Round 615(Div.3)","date":"2020-01-23T09:51:39.000Z","updated":"2020-01-23T03:43:47.061Z","comments":true,"path":"2020/01/23/CodeForces Round 615(Div.3)/","link":"","permalink":"https//:ForgGYLH.github.io/2020/01/23/CodeForces%20Round%20615(Div.3)/","excerpt":"第一场AK的div3，写一篇题解纪念一下。 传送门","text":"第一场AK的div3，写一篇题解纪念一下。 传送门 注:题解比较简单，没有题意，大家笑一笑就好^^_ 整体难度 A&lt;B&lt;C&lt;D&lt;F&lt;E（大概吧 A. Collecting Coins 先把A,B,C填平了，再看看剩下的n能否整除3. #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll a[3]; void solve(){ ll n;scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a[0],&amp;a[1],&amp;a[2],&amp;n); sort(a,a+3); ll k=a[2]-a[0]+a[2]-a[1]; if(n&lt;k||(n-k)%3){ printf(&quot;NO\\n&quot;); }else printf(&quot;YES\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } B. Collecting Packages 根据题意可知，能先往右边走就先往右边走，然后再上去，根据高度从低到高排序然后模拟即可. 如果排完序还出现往左下走的情况就说明不合法。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; struct node{ int x,y; }a[1010]; int cmp(node p,node q){ return p.x&lt;q.x||p.x==q.x&amp;&amp;p.y&lt;q.y; } vector&lt;int&gt;v; void solve(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); }sort(a+1,a+n+1,cmp); v.clear();int x=0,y=0; for(int i=1;i&lt;=n;i++){ if(a[i].x&lt;x||a[i].y&lt;y){ printf(&quot;NO\\n&quot;);return; }for(int j=1;j&lt;=a[i].x-x;j++){ v.push_back(1); }for(int j=1;j&lt;=a[i].y-y;j++){ v.push_back(2); }x=a[i].x;y=a[i].y; }printf(&quot;YES\\n&quot;); for(int i=0;i&lt;v.size();i++){ if(v[i]==1) printf(&quot;R&quot;); else printf(&quot;U&quot;); }printf(&quot;\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } C. Product of Three Numbers 没啥好说的，能判断3个是不同的就好了，乱搞题。 这里推荐施老师的代码（@syh0313 简洁清楚 我的就比较丢人 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; using namespace std; int T,n,a,b; int main() { scanf(&quot;%d&quot;,&amp;T); while (T--) { scanf(&quot;%d&quot;,&amp;n); a=-1; b=-1; for (int i=2;1ll*i*i&lt;=n;i++) if (n%i==0) {a=i; n/=i; break;} for (int i=2;1ll*i*i&lt;=n;i++) if (n%i==0 &amp;&amp; i!=a &amp;&amp; i!=n/i) {b=i; n/=i; break;} if (a==-1 || b==-1) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n%d %d %d\\n&quot;,a,b,n); } return 0; } D. MEX maximizing 这道题看起来比较吓人，代码其实就10行.可以发现答案是单调递增的，我们可以把所有数先减到不能再减，即取模:a[i]=a[i]%x;再把当前答案也取个模,就能轻松模拟了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=4e5+50; int vis[maxn]; int main(){ int now=0;memset(vis,0,sizeof(vis)); int n,k;scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){int x; scanf(&quot;%d&quot;,&amp;x);vis[x%k]++; int y=now/k; while(vis[now%k]&gt;=y+1){ now++;y=now/k; }printf(&quot;%d\\n&quot;,now); } } E. Obtain a Permutation 卡了很久的一道构造题，能发现移动的方式其实很有限，所以可以每列单独考虑，对每一列来说，要么全部替换，要么先移位再替换，移位的思路：对于每一个符合当列要求（即v [i] [j] %m==j%m）的数，算出离它应该呆的位置的距离x，然后用一个数组记录下来，即vis[x]++;最后答案就是ans[j]=min(ans[j],i+(n-vis[i])); #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; vector&lt;int&gt;v[maxn]; int ans[maxn];int vis[maxn]; int main(){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ v[i].push_back(0); for(int j=1;j&lt;=m;j++){int x; scanf(&quot;%d&quot;,&amp;x);v[i].push_back(x); } }int res=0; for(int j=1;j&lt;=m;j++){ ans[j]=0; for(int i=1;i&lt;=n;i++){ if(v[i][j]!=(i-1)*m+j){ ans[j]++; } } for(int i=0;i&lt;n;i++) vis[i]=0; for(int i=1;i&lt;=n;i++){ if(v[i][j]%m==j%m){ int now=(v[i][j]-j)/m;now++; if(now&gt;n) continue; vis[(i-now+n)%n]++; } }for(int i=0;i&lt;n;i++){ ans[j]=min(ans[j],i+(n-vis[i])); }res+=ans[j]; } printf(&quot;%d\\n&quot;,res); } F. Three Paths on a Tree 先找出一条直径，直径的两端点就是第一二个点。再在直径经过的每一个点上深搜，搜到的那个最远的点就是第三个点 又是4个dfs( #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; vector&lt;int&gt;g[maxn]; int vis[maxn];int ss,tt,mxpos; int ans=0,th; void dfs1(int now,int fa,int pos){ if(pos&gt;=mxpos){ ss=now;mxpos=pos; }for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa) continue;dfs1(e,now,pos+1); } }void dfs2(int now,int fa,int pos){ if(pos&gt;=mxpos){ tt=now;mxpos=pos; }for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa) continue;dfs2(e,now,pos+1); } }int dfs3(int now,int fa){ int flag=0; if(now==tt) flag=1; for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa) continue;if(dfs3(e,now)){ vis[now]=1;flag=1; } } return flag; }void dfs4(int now,int fa,int pos){ if(pos&gt;ans){ ans=pos;th=now; }for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa||vis[e]) continue; dfs4(e,now,pos+1); } } int main(){ int n;scanf(&quot;%d&quot;,&amp;n);memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n-1;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); g[a].push_back(b);g[b].push_back(a); }mxpos=0;dfs1(1,-1,0);mxpos=0;dfs2(ss,-1,0);vis[ss]=vis[tt]=1; dfs3(ss,-1); for(int i=1;i&lt;=n;i++){ if(vis[i]&amp;&amp;i!=ss&amp;&amp;i!=tt){ th=i; } } for(int i=1;i&lt;=n;i++){ if(vis[i]){ dfs4(i,-1,0); } }printf(&quot;%d\\n%d %d %d&quot;,mxpos+ans,ss,tt,th); } 还要继续努力 qwq","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1271E-Common Number","slug":"CF1271E-Common Number","date":"2019-12-17T09:51:39.000Z","updated":"2020-01-01T09:22:38.902Z","comments":true,"path":"2019/12/17/CF1271E-Common Number/","link":"","permalink":"https//:ForgGYLH.github.io/2019/12/17/CF1271E-Common%20Number/","excerpt":"这道题，一开始以为是什么牛逼的数学题 后来发现好像答案满足单调性？？ 于是二分check就完事了 稳妥一点就分奇偶分别check 像我就喜欢骚一点 直接一遍check 复杂度O(logn^2) 快的一批","text":"这道题，一开始以为是什么牛逼的数学题 后来发现好像答案满足单调性？？ 于是二分check就完事了 稳妥一点就分奇偶分别check 像我就喜欢骚一点 直接一遍check 复杂度O(logn^2) 快的一批 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll n,k; int ok(ll x){ ll cnt=1;ll l=x,r=x; if(x%2==0&amp;&amp;x&lt;n){ cnt++;r++; } while(1){ ll l1=l*2,r1=r*2+1; if(r1&gt;n){ if(l1&gt;n){ return cnt&gt;=k; } return (cnt+n-l1+1)&gt;=k; } cnt+=r1-l1+1;r=r1;l=l1; } } ll bs(ll l,ll r){ ll ans=l; while(l&lt;=r){ ll mid=(l+r)/2; if(mid%2&amp;&amp;mid+1&lt;=r){ mid+=1; } if(ok(mid)){ ans=mid; l=mid+1; }else{ r=mid-1; } } return ans; } int main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); printf(&quot;%lld\\n&quot;,bs(1,n)); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"2019广工新生赛sabee题解","slug":"2019广工新生赛sabee题解","date":"2019-12-10T09:51:39.000Z","updated":"2020-01-01T09:21:48.493Z","comments":true,"path":"2019/12/10/2019广工新生赛sabee题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/12/10/2019%E5%B9%BF%E5%B7%A5%E6%96%B0%E7%94%9F%E8%B5%9Bsabee%E9%A2%98%E8%A7%A3/","excerpt":"suibianxiexie","text":"suibianxiexie A-原初的信纸 题目链接 签到成功，这是你的签到奖励.jpg #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; int a[maxn]; void solve(){ int n;scanf(&quot;%d&quot;,&amp;n);int mx=0; for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); mx=max(mx,a[i]); } printf(&quot;%d\\n&quot;,mx); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--){ solve(); } } tags: *500 B-骑士的对决 题目链接 签到成功，这是你的签到奖励.jpg #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; int main(){ char a,b,c,d; scanf(&quot;%c%c%c%c&quot;,&amp;a,&amp;b,&amp;c,&amp;d); if(d==&#39;S&#39;&amp;&amp;a==&#39;S&#39;&amp;&amp;b==&#39;J&#39;||d==&#39;S&#39;&amp;&amp;a==&#39;J&#39;&amp;&amp;b==&#39;S&#39;||d==&#39;J&#39;&amp;&amp;a==&#39;B&#39;&amp;&amp;b==&#39;J&#39;||d==&#39;J&#39;&amp;&amp;a==&#39;J&#39;&amp;&amp;b==&#39;B&#39;||d==&#39;B&#39;&amp;&amp;a==&#39;B&#39;&amp;&amp;b==&#39;S&#39;||d==&#39;B&#39;&amp;&amp;a==&#39;S&#39;&amp;&amp;b==&#39;B&#39;){ printf(&quot;lyrnb&quot;); }else{ printf(&quot;pmznb&quot;); } } tags: game *600 C-秘密的议会 题目链接 签到成功，这是你的签到奖励.jpg #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; void solve(){ char ch[110]; scanf(&quot;%s&quot;,ch); int n=strlen(ch); int cnt1=0;int cnt2=0; for(int i=0;i&lt;n;i++){ if(ch[i]==&#39;Y&#39;||ch[i]==&#39;y&#39;){ cnt1++; }else if(ch[i]==&#39;N&#39;||ch[i]==&#39;n&#39;){ cnt2++; } } if(cnt1&gt;=n/2){ printf(&quot;pmznb\\n&quot;); }else if(cnt2&gt;=n/2){ printf(&quot;lyrnb\\n&quot;); }else printf(&quot;wsdd\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve(); } tags: *600 D-城市的税金 题目链接 按题意模拟即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll a[maxn]; int n,m; ll fun(ll x){ return x*251%996*404*123; } map&lt;ll,int&gt;mp; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); } while(m--){ ll op,b,c; scanf(&quot;%lld%lld%lld&quot;,&amp;op,&amp;b,&amp;c); if(op==1){ for(int i=b;i&lt;=c;i++){ a[i]=fun(a[i]); } }else{ mp.clear();int ans=0; for(int i=b;i&lt;=c;i++){ mp[a[i]]++; ans=max(ans,mp[a[i]]); } printf(&quot;%d\\n&quot;,ans); } } } tags: implementation data strcutres *700 E-缺席的神官 题目链接 基础贪心，将工作日之间的间隔加入优先队列，取前k个即可。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll a[maxn]; int n,m,k; int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); int sum=a[n]-a[1]+1; priority_queue&lt;int&gt;q; for(int i=1;i&lt;n;i++){ q.push(a[i+1]-a[i]-1); } k--; while(k--){ sum-=q.top();q.pop(); } printf(&quot;%d\\n&quot;,sum); } tags: greedy *1000 F-失踪的玫瑰 题目链接 待补 tags:math *2200 G-虚数的纸牌 题目链接 sb模拟题，按题意模拟即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int f1(int x){ if(x==4) return 6; if(x==3) return 3; if(x==2) return 1; } int f2(int x){ if(x==4) return 4; return 1; } char ch[20]; int cnt[15]; void solve(){ scanf(&quot;%s&quot;,ch); memset(cnt,0,sizeof(cnt)); int n=strlen(ch); for(int i=0;i&lt;n;i++){ if(ch[i]&gt;=&#39;3&#39;&amp;&amp;ch[i]&lt;=&#39;9&#39;){ cnt[ch[i]-&#39;3&#39;]++; }else if(ch[i]==&#39;0&#39;) cnt[7]++; else if(ch[i]==&#39;A&#39;) cnt[11]++; else if(ch[i]==&#39;2&#39;) cnt[12]++; else if(ch[i]==&#39;J&#39;) cnt[8]++; else if(ch[i]==&#39;Q&#39;) cnt[9]++; else if(ch[i]==&#39;K&#39;) cnt[10]++; } int ans=17; for(int i=0;i&lt;=12;i++){ if(cnt[i]&gt;=2){ ans+=f1(cnt[i]); }if(cnt[i]&gt;=3){ ans+=f2(cnt[i])*(17-cnt[i]); int res=0; for(int j=0;j&lt;=12;j++){ if(i==j) continue; if(cnt[j]&gt;=2){ res+=f1(cnt[j]); } } ans+=res*f2(cnt[i]); }if(cnt[i]==4){ ans++; } } for(int i=0;i&lt;=8;i++){ if(cnt[i]&amp;&amp;cnt[i+1]&amp;&amp;cnt[i+2]&amp;&amp;cnt[i+3]&amp;&amp;cnt[i+4]){ ans+=cnt[i]*cnt[i+1]*cnt[i+2]*cnt[i+3]*cnt[i+4]; } } printf(&quot;%d\\n&quot;,ans); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } tags: implementation *1000 H-绵羊的硬币 题目链接 打个表 天才wz嘴了正解 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll fib[110]; void solve(){ ll n;scanf(&quot;%lld&quot;,&amp;n); ll now=1;int cnt=0; for(int i=0;i&lt;=60;i++){ if(now&gt;n){ break; } now*=2;cnt++; } printf(&quot;%lld\\n&quot;,fib[cnt]); } int main(){ fib[1]=1;fib[2]=1; for(int i=3;i&lt;=100;i++){ fib[i]=fib[i-1]+fib[i-2]; }int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } tags: math,brute force,*1300 I-迷途的怪物 题目链接 找规律，当n为奇数时答案为1，n为偶数时答案为p-1;就是这么简单 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll p;char n[1000010]; void solve(){ scanf(&quot;%lld%s&quot;,&amp;p,n); int len=strlen(n); int ok=n[len-1]-&#39;0&#39;; if(ok%2==0){ printf(&quot;1\\n&quot;); }else{ printf(&quot;%lld\\n&quot;,p-1); } } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } tags: math,brute force,*1500 J-简单的数学 题目链接 简单数学题（不是 只要你认真求导 发现当x=1代进去 能消掉一大片233. 代码又是傻逼几行 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; void solve(){ ll n;scanf(&quot;%lld&quot;,&amp;n); if(n%2==0) printf(&quot;-%lld\\n&quot;,n*(n+1)); else printf(&quot;%lld\\n&quot;,n*(n+1)); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--){ solve(); } } tags: math,*1300 K-消亡的质数 题目链接 被天才wz嘲笑了两天 自闭了 傻逼题 但我更sb #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; void solve(){ ll n;scanf(&quot;%lld&quot;,&amp;n); n--;if(n%3){ printf(&quot;NO\\n&quot;);return ; } n/=3;ll p=sqrt(n);if(p*(p+1)==n) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--){ solve(); } } tags: math,*-1 L-危险的台阶 待补 tags:math, *2500 M-破碎的愿望 题目链接 为什么，明明是我最爱字符串题，为什么会变成这样。。。 写了1w年 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; char ch[40]; int main(){ int n;ll k;scanf(&quot;%d%lld&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,ch); ll x1=k/n;ll x2=k%n; if(x2) x1++; if(x1%2==0) reverse(ch,ch+n); x2=(k-1)%n; printf(&quot;%c&quot;,ch[x2]); } tags:strings *500","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces图论刷题之路 2-1245D. Shichikuji and Power Grid","slug":"graph2","date":"2019-11-09T07:49:22.000Z","updated":"2019-11-09T07:57:33.705Z","comments":true,"path":"2019/11/09/graph2/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/09/graph2/","excerpt":"一道看似很牛逼实际上很sb的最小生成树，绝了。","text":"一道看似很牛逼实际上很sb的最小生成树，绝了。 先对原图建立一个完全图，边权如题所示，再建立一个虚拟源点，每个点和源点都连一条边，权值为建造这个点为发电站的值。然后跑最小生成树。。。艹，这也太sb了。 时间复杂度 O(N2)； 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxe=4e6+50; const int maxn=2050; struct node{ int s,t; ll val; }edge[maxe],ans0[maxn],ans1[maxn]; int bel[maxn]; int vis[maxn]; ll x[maxn],y[maxn],cost[maxn]; int cnt,n,res0,res1; int cmp(node a,node b){ return a.val&lt;b.val; } int find(int x){ if(bel[x]!=x){ return bel[x]=find(bel[x]); } return x; } void merge(int x,int y){ int fx=find(x); int fy=find(y); if(fx!=fy){ bel[max(fx,fy)]=min(fx,fy); } } void init(){ for(int i=0;i&lt;=n;i++){ vis[i]=0; bel[i]=i; } cnt=0;res0=0;res1=0; } void add(int a,int b,ll c){ edge[cnt].s=a; edge[cnt].t=b; edge[cnt++].val=c; } ll kruskal(){ ll ans=0; int count=0; sort(edge,edge+cnt,cmp); for(int i=0;i&lt;cnt;i++){ if(find(edge[i].s)!=find(edge[i].t)){ ans+=edge[i].val; merge(edge[i].s,edge[i].t); count++; if(edge[i].s==0||edge[i].t==0) ans0[++res0]=edge[i]; else ans1[++res1]=edge[i]; } if(count==n) break; } return ans; } int main(){ scanf(&quot;%d&quot;,&amp;n); init(); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]); }for(int i=1;i&lt;=n;i++){ ll x;scanf(&quot;%lld&quot;,&amp;x); add(0,i,x); }for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;cost[i]); for(int j=1;j&lt;i;j++){ ll c=abs(x[i]-x[j])+abs(y[i]-y[j]); c*=(cost[i]+cost[j]); add(i,j,c); } } printf(&quot;%lld\\n&quot;,kruskal()); printf(&quot;%d\\n&quot;,res0); for(int i=1;i&lt;=res0;i++){ printf(&quot;%d &quot;,max(ans0[i].s,ans0[i].t)); }printf(&quot;\\n%d\\n&quot;,res1); for(int i=1;i&lt;=res1;i++){ printf(&quot;%d %d\\n&quot;,ans1[i].s,ans1[i].t); } }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces图论刷题之路 1-1243D. 0-1 MST","slug":"CFGraphs","date":"2019-11-09T07:36:01.000Z","updated":"2019-11-09T07:46:04.674Z","comments":true,"path":"2019/11/09/CFGraphs/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/09/CFGraphs/","excerpt":"发现自己图论菜的一 所以开始疯狂刷图论题。这是一道看似最小生成树实则是求补图连通块个数的题。","text":"发现自己图论菜的一 所以开始疯狂刷图论题。这是一道看似最小生成树实则是求补图连通块个数的题。 如何求连通块的个数：对每一个节点，如果他没有被讨论过，即vis[i]=0,则对它进行讨论：将那些剩下未讨论的节点逐个遍历，若他们之间没有权值为1的边相连，则说明在补图中他们是连通的，于是将他们归为一个集合，并从未讨论的集合中删除，这样从1到n逐个遍历。复杂度为（n+m）logn，因为看似是先for一遍再在每个i中再for一遍，可由于边也只有1e5条，所以均摊下来复杂度是成立的。 其中 未讨论的集合我放到了set中，已经讨论过就打上vis标记并从v中删除，每一次讨论用dfs将之后能够加入到这个连通块中的点一并加入，这样就不用并查集最后再遍历一遍数个数了。 QAQ。。。。 时间：140ms 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+50; const int INF = 1e9; set&lt;int&gt;g[maxn]; set&lt;int&gt;v; int vis[maxn]; void dfs(int x){ vis[x]=1; vector&lt;int&gt;tmp; for(int i:v){ if(!g[x].count(i)){ tmp.push_back(i); } } for(int i:tmp){ v.erase(i); } for(int i:tmp){ dfs(i); } } int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); g[a].insert(b);g[b].insert(a); } for(int i=1;i&lt;=n;i++){ v.insert(i); } //memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) vis[i]=0;int ans=0; for(int i=1;i&lt;=n;i++){ if(!vis[i]){ ans++; v.erase(i); dfs(i); } } printf(&quot;%d\\n&quot;,ans-1); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1256B-Minimize the Permutation题解","slug":"CF1256b-Minimize the Permutation题解","date":"2019-11-05T13:11:55.000Z","updated":"2019-11-05T13:23:46.967Z","comments":true,"path":"2019/11/05/CF1256b-Minimize the Permutation题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/05/CF1256b-Minimize%20the%20Permutation%E9%A2%98%E8%A7%A3/","excerpt":"这道题。。比赛时候甚至写炸了 555 我太菜了","text":"这道题。。比赛时候甚至写炸了 555 我太菜了 题解：因为每个交换只能用一次 而且数据范围贼小 直接n2暴力即可 方法：从1枚举到N 当枚举到一个i时 贪心地把i往前移动，如果当前所在位置的移动机会已经用掉或者前面一个数比当前的数要小 则停止移动 n2是因为我懒得写VIS数组了。。直接暴力找 on的解法也很容易写 上代码 n2 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=110+50; typedef long long ll; int a[maxn]; int vis[maxn]; int main(){ int t,n; scanf(&quot;%d&quot;,&amp;t); while(t--){ memset(vis,0,sizeof(vis)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=1;i&lt;=n;i++){ int now; for(int j=1;j&lt;=n;j++){ if(a[j]==i){ now=j;break; } } for(int j=now;j&gt;=2;j--){ if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1]){ swap(a[j],a[j-1]); vis[j-1]=1; }else{ break; } } } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); } } on 加了个pos数组存储位置 实时更新 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=110+50; typedef long long ll; int a[maxn]; int vis[maxn]; int pos[maxn]; int main(){ int t,n; scanf(&quot;%d&quot;,&amp;t); while(t--){ memset(vis,0,sizeof(vis)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); pos[a[i]]=i; } for(int i=1;i&lt;=n;i++){ int now=pos[i]; for(int j=now;j&gt;=2;j--){ if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1]){ swap(pos[a[j]],pos[a[j-1]]); swap(a[j],a[j-1]); vis[j-1]=1; }else{ break; } } } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); } } 。。多练吧QAQ","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"LuoGuP1470【最长前缀LongestPrefix】","slug":"LuoGuP1470【最长前缀LongestPrefix】","date":"2019-11-04T09:54:20.000Z","updated":"2019-11-05T04:11:11.060Z","comments":true,"path":"2019/11/04/LuoGuP1470【最长前缀LongestPrefix】/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/LuoGuP1470%E3%80%90%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80LongestPrefix%E3%80%91/","excerpt":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。","text":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。 上代码 #include &lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; const int maxn=5050; const int INF = 0x3f3f3f3f; int tree[maxn][30]; bool vis[2020][200020]; int ed[maxn]; char que[200020]; char ch[20]; int n,cnt,Len; int ans=0; int newnode(){ for(int i=0;i&lt;=26;i++){ tree[cnt][i]=-1; } ed[cnt]=0; return cnt++; } void init(){ cnt=0; newnode(); } void insert(){ int len=strlen(ch); int root=0; for(int i=0;i&lt;len;i++){ int x=ch[i]-&#39;A&#39;; if(tree[root][x]&lt;=0){ tree[root][x]=newnode(); } root=tree[root][x]; } ed[root]=1; } void dfs(int pos,int len){ if(vis[pos][len]) return; vis[pos][len]=1; int x=que[len]-&#39;A&#39;; if(ed[pos]){ ans=max(ans,len); } if(len==Len){ return; } if(tree[pos][x]!=-1){ dfs(tree[pos][x],len+1); }if(ed[pos]){ dfs(0,len); } } int main(){ init(); while(scanf(&quot;%s&quot;,ch)&amp;&amp;strcmp(ch,&quot;.&quot;)){ insert(); } Len=0; while(scanf(&quot;%s&quot;,que+Len)!=EOF){ Len=strlen(que); } dfs(0,0); printf(&quot;%d\\n&quot;,ans); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"To Do List","slug":"ToDoList","date":"2019-11-04T09:51:39.000Z","updated":"2020-01-01T09:23:31.633Z","comments":true,"path":"2019/11/04/ToDoList/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/ToDoList/","excerpt":"断断续续搞了两三天，终于是完工了，可以开始写博客了。","text":"断断续续搞了两三天，终于是完工了，可以开始写博客了。 第一篇博客 总要定一点远大的理想 那下面就是To-Do-List：1.染个头发+买个显示器2.上个紫名3.学点图论 搞点数论字符串4.经常更博5.一等奖学金6.校赛天梯赛一血前耻7.拿到参加省赛的机会8.拿到尽可能多的参赛机会 9.CCPC ICPC Golden medal暂时先列这么多….有想法再补 FrogG冲冲冲!想一下接下来要学习和巩固的算法 图论：最短路dij 网络流相关 数据结构：线段树 平衡树 DP 搜索相关 杂项：差分约束 2-sat 位运算相关 分治 数论相关。。。 字符串：后缀数组 定个小目标 扫荡1900分以下的题","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https//:ForgGYLH.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]}