{"meta":{"title":"进来坐坐呗~","subtitle":"一只数论自闭字符串不会的菜狗","description":"Hachi赛高","author":"FrogG_YLH.","url":"https//:ForgGYLH.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-31T10:44:01.000Z","updated":"2019-11-03T12:44:40.135Z","comments":true,"path":"categories/index.html","permalink":"https//:ForgGYLH.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-10-31T10:43:52.000Z","updated":"2019-11-03T12:45:59.743Z","comments":true,"path":"tags/index.html","permalink":"https//:ForgGYLH.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CF1256B-Minimize the Permutation题解","slug":"CF1256b-Minimize the Permutation题解","date":"2019-11-05T13:11:55.000Z","updated":"2019-11-05T13:23:46.967Z","comments":true,"path":"2019/11/05/CF1256b-Minimize the Permutation题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/05/CF1256b-Minimize%20the%20Permutation%E9%A2%98%E8%A7%A3/","excerpt":"这道题。。比赛时候甚至写炸了 555 我太菜了","text":"这道题。。比赛时候甚至写炸了 555 我太菜了 题解：因为每个交换只能用一次 而且数据范围贼小 直接n2暴力即可 方法：从1枚举到N 当枚举到一个i时 贪心地把i往前移动，如果当前所在位置的移动机会已经用掉或者前面一个数比当前的数要小 则停止移动 n2是因为我懒得写VIS数组了。。直接暴力找 on的解法也很容易写 上代码 n2 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=110+50;typedef long long ll;int a[maxn];int vis[maxn];int main()&#123; int t,n; scanf(\"%d\",&amp;t); while(t--)&#123; memset(vis,0,sizeof(vis)); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); &#125; for(int i=1;i&lt;=n;i++)&#123; int now; for(int j=1;j&lt;=n;j++)&#123; if(a[j]==i)&#123; now=j;break; &#125; &#125; for(int j=now;j&gt;=2;j--)&#123; if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1])&#123; swap(a[j],a[j-1]); vis[j-1]=1; &#125;else&#123; break; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); &#125;&#125; on 加了个pos数组存储位置 实时更新 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=110+50;typedef long long ll;int a[maxn];int vis[maxn];int pos[maxn];int main()&#123; int t,n; scanf(\"%d\",&amp;t); while(t--)&#123; memset(vis,0,sizeof(vis)); scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); pos[a[i]]=i; &#125; for(int i=1;i&lt;=n;i++)&#123; int now=pos[i]; for(int j=now;j&gt;=2;j--)&#123; if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1])&#123; swap(pos[a[j]],pos[a[j-1]]); swap(a[j],a[j-1]); vis[j-1]=1; &#125;else&#123; break; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) printf(\"%d \",a[i]); printf(\"\\n\"); &#125;&#125; 。。多练吧QAQ","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1256b-MinimizethePermutation题解","slug":"CF1256b-MinimizethePermutation题解","date":"2019-11-05T13:11:55.000Z","updated":"2019-11-05T13:11:55.433Z","comments":true,"path":"2019/11/05/CF1256b-MinimizethePermutation题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/05/CF1256b-MinimizethePermutation%E9%A2%98%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"LuoGuP1470【最长前缀LongestPrefix】","slug":"LuoGuP1470【最长前缀LongestPrefix】","date":"2019-11-04T09:54:20.000Z","updated":"2019-11-05T04:11:11.060Z","comments":true,"path":"2019/11/04/LuoGuP1470【最长前缀LongestPrefix】/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/LuoGuP1470%E3%80%90%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80LongestPrefix%E3%80%91/","excerpt":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。","text":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。 上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;const int maxn=5050;const int INF = 0x3f3f3f3f;int tree[maxn][30];bool vis[2020][200020];int ed[maxn];char que[200020];char ch[20];int n,cnt,Len;int ans=0;int newnode()&#123; for(int i=0;i&lt;=26;i++)&#123; tree[cnt][i]=-1; &#125; ed[cnt]=0; return cnt++;&#125;void init()&#123; cnt=0; newnode();&#125;void insert()&#123; int len=strlen(ch); int root=0; for(int i=0;i&lt;len;i++)&#123; int x=ch[i]-'A'; if(tree[root][x]&lt;=0)&#123; tree[root][x]=newnode(); &#125; root=tree[root][x]; &#125; ed[root]=1;&#125;void dfs(int pos,int len)&#123; if(vis[pos][len]) return; vis[pos][len]=1; int x=que[len]-'A'; if(ed[pos])&#123; ans=max(ans,len); &#125; if(len==Len)&#123; return; &#125; if(tree[pos][x]!=-1)&#123; dfs(tree[pos][x],len+1); &#125;if(ed[pos])&#123; dfs(0,len); &#125;&#125;int main()&#123; init(); while(scanf(\"%s\",ch)&amp;&amp;strcmp(ch,\".\"))&#123; insert(); &#125; Len=0; while(scanf(\"%s\",que+Len)!=EOF)&#123; Len=strlen(que); &#125; dfs(0,0); printf(\"%d\\n\",ans);&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"我来辣-ToDoList","slug":"我来辣-ToDoList","date":"2019-11-04T09:51:39.000Z","updated":"2019-11-04T09:52:44.103Z","comments":true,"path":"2019/11/04/我来辣-ToDoList/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/%E6%88%91%E6%9D%A5%E8%BE%A3-ToDoList/","excerpt":"断断续续搞了两三天，终于是完工了，可以开始写博客了。","text":"断断续续搞了两三天，终于是完工了，可以开始写博客了。 第一篇博客 总要定一点远大的理想 那下面就是ToDoList：1.染个头发+买个显示器2.上个紫名3.学点图论 搞点数论字符串4.经常更博5.一等奖学金6.校赛天梯赛一血前耻7.拿到参加省赛的机会8.拿到尽可能多的参赛机会9.CCPC ICPC 银牌 暂时先列这么多….有想法再补 FrogG冲冲冲!","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https//:ForgGYLH.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]}