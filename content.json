{"meta":{"title":"我们都有光明的前途","subtitle":"想拿金牌想上红名","description":"Hachi赛高","author":"西瓜喵喵.","url":"https//:ForgGYLH.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-10-31T10:44:01.000Z","updated":"2019-11-03T12:44:40.135Z","comments":true,"path":"categories/index.html","permalink":"https//:ForgGYLH.github.io/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2013-07-13T12:46:25.000Z","updated":"2020-06-10T06:02:25.058Z","comments":true,"path":"PY.html","permalink":"https//:ForgGYLH.github.io/PY.html","excerpt":"","text":"友情链接wenzhuan 稳赚 willingox 刘老师 K0u1e 阿燕 codgician zsj学长 axiomofchoice hjt永远滴神 Edwiv 郑老师 UniverseofHK jxl ILLLZKQF 施老师 jiedai 小汤"},{"title":"tags","date":"2019-10-31T10:43:52.000Z","updated":"2019-11-03T12:45:59.743Z","comments":true,"path":"tags/index.html","permalink":"https//:ForgGYLH.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSP-化学方程式（模拟）","slug":"CSP","date":"2020-06-10T15:33:33.000Z","updated":"2020-06-10T06:04:10.580Z","comments":true,"path":"2020/06/10/CSP/","link":"","permalink":"https//:ForgGYLH.github.io/2020/06/10/CSP/","excerpt":"传送门（需要登录）","text":"传送门（需要登录） 题意：化学方程式，也称为化学反应方程式，是用化学式表示化学反应的式子。给出一组化学方程式，请你编写程序判断每个方程式是否配平（也就是方程式中等号左右两边的元素种类和对应的原子个数是否相同）。本题给出的化学方程式由大小写字母、数字和符号（包括等号=、加号+、左圆括号和右圆括号）组成，不会出现其他字符（包括空白字符，如空格、制表符等），化学方程式的格式与化学课本中的形式基本相同（化学式中表示元素原子个数的下标用正常文本，如H2O写成H2O），用自然语言描述如下： 化学方程式由左右两个表达式组成，中间用一个等号三连接，如2H2+O2=2H2O； 表达式由若干部分组成，每部分由系数和化学式构成，部分之间用加号+连接，如2H2+O2、2H2O； 系数是整数或空串，如为空串表示系数为1； 整数由一个或多个数字构成； 化学式由若干部分组成，每部分由项和系数构成，部分之间直接连接，如H2O、CO2、Ca(OH)2、Ba3(PO4)2； 项是元素或用左右圆括号括起来的化学式，如H、Ca、(OH)、(P04)； 元素可以是一个大写字母，也可以是一个大写字母跟着一个小写字母，如H、O、Ca。输入：11H2+O2=H2O2H2+O2=2H2OH2+Cl2=2NaClH2+Cl2=2HClCH4+2O2=CO2+2H2OCaCl2+2AgNO3=Ca(NO3)2+2AgCl3Ba(OH)2+2H3PO4=6H2O+Ba3(PO4)23Ba(OH)2+2H3PO4=Ba3(PO4)2+6H2O4Zn+10HNO3=4Zn(NO3)2+NH4NO3+3H2O4Au+8NaCN+2H2O+O2=4Na(Au(CN)2)+4NaOHCu+As=Cs+Au输出：NYNYYYYYYYN 思路：一道小模拟吧算是，难点主要在嵌套的括号这里，我用了递归实现，传回去的参数我选择了 map&lt;string,int&gt;。其他也没什么好说的。 题外话：这应该是近期的最后一篇博文了，这个博客近期应该是闲置了。顺便这道题我也是1A，小小纪念一下。 话不多说，直接上代码。作为一个小模拟50行出头还是很可以的（ #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e3+50; char ch[maxn],tmp[maxn],dig[maxn]; map&lt;string,int&gt;mp; int j,p; bool isdig(char x){ return x&gt;=&#39;0&#39;&amp;&amp;x&lt;=&#39;9&#39;; }bool islower(char x){ return x&gt;=&#39;a&#39;&amp;&amp;x&lt;=&#39;z&#39;; }int getdig(){ int tp=0,xs=0; while(isdig(tmp[j])&amp;&amp;j&lt;p){ dig[tp++]=tmp[j];j++; }dig[tp]=0;xs=atoi(dig);if(!xs) xs=1; return xs; }map&lt;string,int&gt; analyze(){ map&lt;string,int&gt; mm,now; while(j&lt;p){ string x; if(tmp[j]==&#39;(&#39;){ j++;mm=analyze(); for(auto y:mm) now[y.first]+=y.second; }else if(tmp[j]==&#39;)&#39;){ j++;int xs=getdig(); for(auto y:now){ //cout&lt;&lt;y.first&lt;&lt;y.second*xs&lt;&lt;endl; now[y.first]=y.second*xs; }return now; }else{ x+=tmp[j++];if(islower(tmp[j])) x+=tmp[j++]; int xs=getdig();now[x]+=xs; } }return now; }void solve(){ scanf(&quot;%s&quot;,ch);mp.clear(); int n=strlen(ch);p=0; int flg=1; for(int i=0;i&lt;=n;i++){ if(i==n||ch[i]==&#39;+&#39;||ch[i]==&#39;=&#39;){ j=0; tmp[p]=0;int xs=getdig(); map&lt;string,int&gt; mm=analyze();p=0; for(auto y:mm){ //cout&lt;&lt;y.first&lt;&lt;y.second*xs&lt;&lt;endl; mp[y.first]+=y.second*xs*flg; }if(ch[i]==&#39;=&#39;) flg=-1; }else tmp[p++]=ch[i]; }for(auto y:mp) if(y.second!=0) return (void)printf(&quot;N\\n&quot;); printf(&quot;Y\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); return 0; } 我们有缘再会~ ​ By FrogGLeader","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Codeforces Round 642 (Div.3)","slug":"CF642","date":"2020-05-15T09:51:39.000Z","updated":"2020-05-15T09:19:04.130Z","comments":true,"path":"2020/05/15/CF642/","link":"","permalink":"https//:ForgGYLH.github.io/2020/05/15/CF642/","excerpt":"","text":"这场3 D都不会 太耻辱了","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Codeforces Round 637 (Div.1)","slug":"cf637 - 副本","date":"2020-04-24T09:51:39.000Z","updated":"2020-04-24T05:28:55.129Z","comments":true,"path":"2020/04/24/cf637 - 副本/","link":"","permalink":"https//:ForgGYLH.github.io/2020/04/24/cf637%20-%20%E5%89%AF%E6%9C%AC/","excerpt":"只包括div1的B和C的题解 传送门","text":"只包括div1的B和C的题解 传送门 题解比较简单 我也不写题意了 直接写思路 而且因为div2ABC大家都过了我就不献丑了，直接从2D1B开始 B.Nastya and Scoreboard 可以发现n只有2000 考虑DP，同时又能发现 因为越前面的数字对全局的影响越大，所以肯定要贪心求前面最大的数。因此思路就是 DP预处理+贪心 DP预处理的是：当前我在i这个位置，剩余k0根木棍，选了j（0&lt;=j&lt;=9)这个数字，那么我接下来能否用剩下的木棍（k0-选了j需要的木棍)使剩下的位置满足题目的要求。 DPi,j表示从当前的i到最后的n，能否用j根木棍满足题目要求 转移方式：从n到1遍历，再从0到k遍历，再遍历0到9，看能否由dp i+1,j转移过来 如果可以就标记1 最后贪心从头到尾遍历即可 Code #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; int dp[2020][2020]; int dig[10]={119,18,93,91,58,107,111,82,127,123}; int gun[10]={6,2,5,5,4,5,6,3,7,6}; int a[2020],sum[2020];char ch[10]; void cal(int j){ int now=1;int ans=0,cnt=0; for(int i=6;i&gt;=0;i--){ if(ch[i]==&#39;1&#39;) ans+=now,cnt++;now*=2; }sum[j]=cnt;a[j]=ans; }int main(){ int n,k;scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){ scanf(&quot;%s&quot;,ch);cal(i); }dp[n+1][0]=1; for(int i=n;i&gt;=1;i--){ for(int j=0;j&lt;=k;j++){ if(!dp[i+1][j]) continue; for(int q=0;q&lt;=9;q++){ if(a[i]&lt;=dig[q]&amp;&amp;((a[i]&amp;dig[q])==a[i])){ if(j+gun[q]-sum[i]&lt;=k) dp[i][j+gun[q]-sum[i]]=1; } } } }int now=0,flag=0; for(int i=1;i&lt;=n;i++){ for(int q=9;q&gt;=0;q--){ if(a[i]&lt;=dig[q]&amp;&amp;((a[i]&amp;dig[q])==a[i])){ if(dp[i+1][k-now-(gun[q]-sum[i])]){ flag=1;printf(&quot;%d&quot;,q);now+=gun[q]-sum[i];break; } } }if(!flag) return printf(&quot;-1&quot;),0; } } C.Nastya and Unexpected Guest 这是一道DP+图论题 先对m数组排个序，因为题目给的数据不一定有序 首先我们可以发现 m范围是1e4 g范围是1e3 所以可以想到dp dp i,j表示的是当前在第i个点,绿灯还剩j秒时的最短时间 因为是最短时间，所以这就类似于最短路的思想 所以转移的方式是 一个点可以向它的左边或者右边走，比如3可以走到0或7，7可以走到3或者14 边界点特判一下。 然后既然是最短路 那转移的时候可以用类似dijkstra的思想 其中dpij的值的意思是 当前经过的周期，比如dpij=1 代表到了这个状态经过了1个（绿灯+红灯）的时间 但是我们能发现 dijkstra的复杂度不满足题目的要求 因为题目中光状态就有1e7个 会TLE 然后我们又发现，转移的时候要么在当前绿灯的范围内，要么到了下一个绿灯的周期中，所以dp的值在转移的时候要么不变要么加一，这时候我们就可以用双端队列代替dij中的优先队列，如果不变，那么push进头部，如果+1，push进尾部，这样也可以保证整个队列是有序的 最后枚举最终状态里的绿灯剩余时间，算最小值 （如果有哪里不懂可以边看代码边理解qwq） Code //其中 deque是双端队列 下文还会给出dijkstra优先队列优化的写法，如果不知道的话可以参考一下，大家应该都会吧嘤嘤嘤 #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,int&gt; #define fi first #define sc second using namespace std; typedef long long ll; const int maxn=1e4+5; const int maxe=1e3+5; int a[maxn];int dp[maxn][maxe]; int main(){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+m+1);int g,r;scanf(&quot;%d%d&quot;,&amp;g,&amp;r); for(int i=1;i&lt;=m;i++){ for(int j=0;j&lt;=g;j++) dp[i][j]=1e9; }dp[1][g]=0;deque&lt;pii&gt;q;q.push_front({1,g}); while(!q.empty()){ pii now=q.front();q.pop_front(); int i=now.fi,rem=now.sc; if(i&gt;1){ int dis=a[i]-a[i-1]; if(dis&lt;rem){ if(dp[i-1][rem-dis]&gt;dp[i][rem]){ dp[i-1][rem-dis]=dp[i][rem];q.push_front({i-1,rem-dis}); } }else if(dis==rem){ if(dp[i-1][g]&gt;dp[i][rem]+1){ dp[i-1][g]=dp[i][rem]+1;q.push_back({i-1,g}); } } }if(i&lt;m){ int dis=a[i+1]-a[i]; if(dis&lt;rem){ if(dp[i+1][rem-dis]&gt;dp[i][rem]){ dp[i+1][rem-dis]=dp[i][rem];q.push_front({i+1,rem-dis}); } }else if(dis==rem){ if(dp[i+1][g]&gt;dp[i][rem]+1){ dp[i+1][g]=dp[i][rem]+1;q.push_back({i+1,g}); } } } }ll ans=1e18; for(int i=1;i&lt;g;i++){ if(dp[m][i]!=1e9) ans=min(ans,1ll*dp[m][i]*(g+r)+g-i); }if(dp[m][g]!=1e9) ans=min(ans,1ll*dp[m][g]*(g+r)-r); if(ans==1e18) printf(&quot;-1&quot;);else printf(&quot;%lld\\n&quot;,ans); } //dij优先队列 nlogn #include&lt;bits/stdc++.h&gt; #define pii pair&lt;int,ll&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; const ll INF=1e10; int vis[maxn],path[maxn]; ll dis[maxn]; vector&lt;pii&gt;g[maxn]; int n,m; void dijkstra(int s){ for(int i=1;i&lt;=n;i++){ dis[i]=INF;path[i]=-1; }dis[s]=0; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt; &gt;q; q.push(make_pair(0,s)); while(!q.empty()){ int now=q.top().second;q.pop(); if(vis[now]) continue;vis[now]=1; for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i].first;ll c=g[now][i].second; if(dis[e]&gt;dis[now]+c){ dis[e]=dis[now]+c; q.push(make_pair(dis[e],e)); path[e]=now; } } } }int main(){ int s; scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;s); for(int i=1;i&lt;=m;i++){ int a,b;ll c; scanf(&quot;%d%d%lld&quot;,&amp;a,&amp;b,&amp;c); g[a].push_back(make_pair(b,c)); }dijkstra(s); for(int i=0;i&lt;n;i++){ printf(&quot;%d %lld:&quot;,i+1,dis[i+1]); int now=i+1; while(path[now]!=-1) printf(&quot;%d &quot;,path[now]),now=path[now]; printf(&quot;\\n&quot;); } }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Codeforces Round 616(Div.2)","slug":"cf616","date":"2020-03-11T09:51:39.000Z","updated":"2020-03-12T14:47:51.927Z","comments":true,"path":"2020/03/11/cf616/","link":"","permalink":"https//:ForgGYLH.github.io/2020/03/11/cf616/","excerpt":"好久没更了，更一场上了大分的div2 赛时rk18 +168（呜呜当时怎么这么猛） 传送门","text":"好久没更了，更一场上了大分的div2 赛时rk18 +168（呜呜当时怎么这么猛） 传送门 整体难度 A&lt;B&lt;C&lt;D&lt;F&lt;E A. Even But Not Even可能是全场写的最煎熬的题了(按题意模拟写的) 赛后知道只要输出两个奇数就好了 艹 我的sb代码 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; char ch[3030]; void solve(){ int n;scanf(&quot;%d%s&quot;,&amp;n,ch);int sum=0;int cnt=-1; for(int i=0;i&lt;n;i++){ sum+=ch[i]-&#39;0&#39;; if((ch[i]-&#39;0&#39;)%2) cnt=i; }if(sum%2==0&amp;&amp;(ch[n-1]-&#39;0&#39;)%2){ printf(&quot;%s\\n&quot;,ch);return; } if(n==1||cnt==-1){ printf(&quot;-1\\n&quot;); return; }sum=0;int flag=-1;for(int i=0;i&lt;=cnt;i++){ sum+=ch[i]-&#39;0&#39;;if((ch[i]-&#39;0&#39;)%2&amp;&amp;i!=cnt) flag=i; }if(sum%2==0){ for(int i=0;i&lt;=cnt;i++) printf(&quot;%c&quot;,ch[i]);printf(&quot;\\n&quot;); }else if(flag==-1){ printf(&quot;-1\\n&quot;); }else{ for(int i=0;i&lt;=cnt;i++) if(i!=flag) printf(&quot;%c&quot;,ch[i]);printf(&quot;\\n&quot;); } } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } 实际上只需要这样 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=(int)2e5+100; int n; char s[maxn]; int solve(){ scanf(&quot;%d%s&quot;,&amp;n,s+1); int cnt=0,ans=0; for(int i=1;i&lt;=n;i++){ if((s[i]-&#39;0&#39;)%2) cnt++,ans=ans*10+s[i]-&#39;0&#39;; if(cnt==2) return printf(&quot;%d\\n&quot;,ans); }return puts(&quot;-1&quot;); } int main(){ int T;cin&gt;&gt;T;while(T--) solve(); } B. Array Sharpening这把我是弱智A题，但是没关系，因为我就要开启王者模式，芜湖起飞，从现在开始我要起飞了~ 不知道他们为啥写的这么慢 贪心想一想 满足最小的情况就行 正反dp一下 然后judge就好了 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=3e5+50; int a[maxn]; int ok1[maxn],ok2[maxn]; int solve(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]),ok1[i]=ok2[i]=0;ok2[n+1]=1; for(int i=n;i&gt;=1;i--){ if(a[i]&gt;=n-i) ok2[i]=1; else break; }for(int i=1;i&lt;=n;i++){ if(a[i]&gt;=i-1) ok1[i]=1; else break; }for(int i=1;i&lt;=n;i++){ if(ok1[i]&amp;&amp;ok2[i]) return printf(&quot;Yes\\n&quot;); }return printf(&quot;No\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } C.Mind Control比较迷幻的一道题，看到3500就知道N2，然后既然要控制人，那我肯定一开始就要控制（但其实我也不知道为什么，单纯因为如果不是这样会非常难写，所以就开莽了），那么在这个基础上，枚举左边需要控制多少人，右边就是k-左边的人数，取最大值，这是第一重循环，然后的话再枚举左边随机的人，因为随机，所以肯定取最小值，这是第二重循环，那么答案其实已经出来了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; int a[3550]; void solve(){ int n,m,k;scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); k=min(k,m-1);int ans=0; for(int i=0;i&lt;=k;i++){ int l=i+1;int r=n-(k-i);int rem=m-k-1;int res=1e9; for(int j=0;j&lt;=rem;j++){ int l1=l+j;int r1=r-(rem-j); int tmp=max(a[l1],a[r1]);res=min(res,tmp); }ans=max(ans,res); }printf(&quot;%d\\n&quot;,ans); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } D.Irreducible Anagrams这波啊，这波是随便猜猜 给你一个串和q个询问，每个询问给定这个串中的子串，问你能否找出另一个串满足“at least one irreducible anagram.” q既然是1e5，那询问复杂度肯定不高，我就直接开始猜结论。 那么有三种情况是判yes的，其余都是no: 1.len为1（很简单，不证了 2.子串开头结尾不相等：那么只要把开头和结尾调换一下，中间复制，就是符合要求的串 3.有三个及以上不同的字母：建立在首尾相同的情况下，假设开头结尾字母为A，剩下两个为BC,我们用B替换开头的A，用C替换结尾的A，注意不能用第二个出现的字母去替换开头。 如：ABCA-&gt;CAAB 而不能AB|CA-&gt;BA|AC AAABCCCA-&gt;CAAAABCC #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; char ch[maxn];int cnt[maxn][30]; int solve(){ int l,r;scanf(&quot;%d%d&quot;,&amp;l,&amp;r); int x=ch[r]-&#39;a&#39;; if(ch[l]!=ch[r]||l==r) return printf(&quot;Yes\\n&quot;); int ans=0; for(int i=0;i&lt;26;i++) if(cnt[r][i]-cnt[l][i]) ans++; if(ans&gt;=3) return printf(&quot;Yes\\n&quot;); else return printf(&quot;No\\n&quot;); } int main(){ scanf(&quot;%s&quot;,ch+1);int q;scanf(&quot;%d&quot;,&amp;q);int n=strlen(ch+1); for(int i=0;i&lt;26;i++) cnt[0][i]=0; for(int i=1;i&lt;=n;i++){ for(int j=0;j&lt;26;j++) cnt[i][j]=cnt[i-1][j]; cnt[i][ch[i]-&#39;a&#39;]++; }while(q--) solve(); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces Round 615(Div.3)","slug":"CodeForces Round 615(Div.3)","date":"2020-01-23T09:51:39.000Z","updated":"2020-01-23T03:43:47.061Z","comments":true,"path":"2020/01/23/CodeForces Round 615(Div.3)/","link":"","permalink":"https//:ForgGYLH.github.io/2020/01/23/CodeForces%20Round%20615(Div.3)/","excerpt":"第一场AK的div3，写一篇题解纪念一下。 传送门","text":"第一场AK的div3，写一篇题解纪念一下。 传送门 注:题解比较简单，没有题意，大家笑一笑就好^^_ 整体难度 A&lt;B&lt;C&lt;D&lt;F&lt;E（大概吧 A. Collecting Coins 先把A,B,C填平了，再看看剩下的n能否整除3. #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll a[3]; void solve(){ ll n;scanf(&quot;%lld%lld%lld%lld&quot;,&amp;a[0],&amp;a[1],&amp;a[2],&amp;n); sort(a,a+3); ll k=a[2]-a[0]+a[2]-a[1]; if(n&lt;k||(n-k)%3){ printf(&quot;NO\\n&quot;); }else printf(&quot;YES\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } B. Collecting Packages 根据题意可知，能先往右边走就先往右边走，然后再上去，根据高度从低到高排序然后模拟即可. 如果排完序还出现往左下走的情况就说明不合法。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; struct node{ int x,y; }a[1010]; int cmp(node p,node q){ return p.x&lt;q.x||p.x==q.x&amp;&amp;p.y&lt;q.y; } vector&lt;int&gt;v; void solve(){ int n;scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d%d&quot;,&amp;a[i].x,&amp;a[i].y); }sort(a+1,a+n+1,cmp); v.clear();int x=0,y=0; for(int i=1;i&lt;=n;i++){ if(a[i].x&lt;x||a[i].y&lt;y){ printf(&quot;NO\\n&quot;);return; }for(int j=1;j&lt;=a[i].x-x;j++){ v.push_back(1); }for(int j=1;j&lt;=a[i].y-y;j++){ v.push_back(2); }x=a[i].x;y=a[i].y; }printf(&quot;YES\\n&quot;); for(int i=0;i&lt;v.size();i++){ if(v[i]==1) printf(&quot;R&quot;); else printf(&quot;U&quot;); }printf(&quot;\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } C. Product of Three Numbers 没啥好说的，能判断3个是不同的就好了，乱搞题。 这里推荐施老师的代码（@syh0313 简洁清楚 我的就比较丢人 #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstdlib&gt; using namespace std; int T,n,a,b; int main() { scanf(&quot;%d&quot;,&amp;T); while (T--) { scanf(&quot;%d&quot;,&amp;n); a=-1; b=-1; for (int i=2;1ll*i*i&lt;=n;i++) if (n%i==0) {a=i; n/=i; break;} for (int i=2;1ll*i*i&lt;=n;i++) if (n%i==0 &amp;&amp; i!=a &amp;&amp; i!=n/i) {b=i; n/=i; break;} if (a==-1 || b==-1) printf(&quot;NO\\n&quot;); else printf(&quot;YES\\n%d %d %d\\n&quot;,a,b,n); } return 0; } D. MEX maximizing 这道题看起来比较吓人，代码其实就10行.可以发现答案是单调递增的，我们可以把所有数先减到不能再减，即取模:a[i]=a[i]%x;再把当前答案也取个模,就能轻松模拟了。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=4e5+50; int vis[maxn]; int main(){ int now=0;memset(vis,0,sizeof(vis)); int n,k;scanf(&quot;%d%d&quot;,&amp;n,&amp;k); for(int i=1;i&lt;=n;i++){int x; scanf(&quot;%d&quot;,&amp;x);vis[x%k]++; int y=now/k; while(vis[now%k]&gt;=y+1){ now++;y=now/k; }printf(&quot;%d\\n&quot;,now); } } E. Obtain a Permutation 卡了很久的一道构造题，能发现移动的方式其实很有限，所以可以每列单独考虑，对每一列来说，要么全部替换，要么先移位再替换，移位的思路：对于每一个符合当列要求（即v [i] [j] %m==j%m）的数，算出离它应该呆的位置的距离x，然后用一个数组记录下来，即vis[x]++;最后答案就是ans[j]=min(ans[j],i+(n-vis[i])); #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; vector&lt;int&gt;v[maxn]; int ans[maxn];int vis[maxn]; int main(){ int n,m;scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ v[i].push_back(0); for(int j=1;j&lt;=m;j++){int x; scanf(&quot;%d&quot;,&amp;x);v[i].push_back(x); } }int res=0; for(int j=1;j&lt;=m;j++){ ans[j]=0; for(int i=1;i&lt;=n;i++){ if(v[i][j]!=(i-1)*m+j){ ans[j]++; } } for(int i=0;i&lt;n;i++) vis[i]=0; for(int i=1;i&lt;=n;i++){ if(v[i][j]%m==j%m){ int now=(v[i][j]-j)/m;now++; if(now&gt;n) continue; vis[(i-now+n)%n]++; } }for(int i=0;i&lt;n;i++){ ans[j]=min(ans[j],i+(n-vis[i])); }res+=ans[j]; } printf(&quot;%d\\n&quot;,res); } F. Three Paths on a Tree 先找出一条直径，直径的两端点就是第一二个点。再在直径经过的每一个点上深搜，搜到的那个最远的点就是第三个点 又是4个dfs( #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; vector&lt;int&gt;g[maxn]; int vis[maxn];int ss,tt,mxpos; int ans=0,th; void dfs1(int now,int fa,int pos){ if(pos&gt;=mxpos){ ss=now;mxpos=pos; }for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa) continue;dfs1(e,now,pos+1); } }void dfs2(int now,int fa,int pos){ if(pos&gt;=mxpos){ tt=now;mxpos=pos; }for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa) continue;dfs2(e,now,pos+1); } }int dfs3(int now,int fa){ int flag=0; if(now==tt) flag=1; for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa) continue;if(dfs3(e,now)){ vis[now]=1;flag=1; } } return flag; }void dfs4(int now,int fa,int pos){ if(pos&gt;ans){ ans=pos;th=now; }for(int i=0;i&lt;g[now].size();i++){ int e=g[now][i]; if(e==fa||vis[e]) continue; dfs4(e,now,pos+1); } } int main(){ int n;scanf(&quot;%d&quot;,&amp;n);memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n-1;i++){ int a,b;scanf(&quot;%d%d&quot;,&amp;a,&amp;b); g[a].push_back(b);g[b].push_back(a); }mxpos=0;dfs1(1,-1,0);mxpos=0;dfs2(ss,-1,0);vis[ss]=vis[tt]=1; dfs3(ss,-1); for(int i=1;i&lt;=n;i++){ if(vis[i]&amp;&amp;i!=ss&amp;&amp;i!=tt){ th=i; } } for(int i=1;i&lt;=n;i++){ if(vis[i]){ dfs4(i,-1,0); } }printf(&quot;%d\\n%d %d %d&quot;,mxpos+ans,ss,tt,th); } 还要继续努力 qwq","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1271E-Common Number","slug":"CF1271E-Common Number","date":"2019-12-17T09:51:39.000Z","updated":"2020-01-01T09:22:38.902Z","comments":true,"path":"2019/12/17/CF1271E-Common Number/","link":"","permalink":"https//:ForgGYLH.github.io/2019/12/17/CF1271E-Common%20Number/","excerpt":"这道题，一开始以为是什么牛逼的数学题 后来发现好像答案满足单调性？？ 于是二分check就完事了 稳妥一点就分奇偶分别check 像我就喜欢骚一点 直接一遍check 复杂度O(logn^2) 快的一批","text":"这道题，一开始以为是什么牛逼的数学题 后来发现好像答案满足单调性？？ 于是二分check就完事了 稳妥一点就分奇偶分别check 像我就喜欢骚一点 直接一遍check 复杂度O(logn^2) 快的一批 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll n,k; int ok(ll x){ ll cnt=1;ll l=x,r=x; if(x%2==0&amp;&amp;x&lt;n){ cnt++;r++; } while(1){ ll l1=l*2,r1=r*2+1; if(r1&gt;n){ if(l1&gt;n){ return cnt&gt;=k; } return (cnt+n-l1+1)&gt;=k; } cnt+=r1-l1+1;r=r1;l=l1; } } ll bs(ll l,ll r){ ll ans=l; while(l&lt;=r){ ll mid=(l+r)/2; if(mid%2&amp;&amp;mid+1&lt;=r){ mid+=1; } if(ok(mid)){ ans=mid; l=mid+1; }else{ r=mid-1; } } return ans; } int main(){ scanf(&quot;%lld%lld&quot;,&amp;n,&amp;k); printf(&quot;%lld\\n&quot;,bs(1,n)); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"2019广工新生赛sabee题解","slug":"2019广工新生赛sabee题解","date":"2019-12-10T09:51:39.000Z","updated":"2020-01-01T09:21:48.493Z","comments":true,"path":"2019/12/10/2019广工新生赛sabee题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/12/10/2019%E5%B9%BF%E5%B7%A5%E6%96%B0%E7%94%9F%E8%B5%9Bsabee%E9%A2%98%E8%A7%A3/","excerpt":"suibianxiexie","text":"suibianxiexie A-原初的信纸 题目链接 签到成功，这是你的签到奖励.jpg #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; int a[maxn]; void solve(){ int n;scanf(&quot;%d&quot;,&amp;n);int mx=0; for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); mx=max(mx,a[i]); } printf(&quot;%d\\n&quot;,mx); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--){ solve(); } } tags: *500 B-骑士的对决 题目链接 签到成功，这是你的签到奖励.jpg #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; int main(){ char a,b,c,d; scanf(&quot;%c%c%c%c&quot;,&amp;a,&amp;b,&amp;c,&amp;d); if(d==&#39;S&#39;&amp;&amp;a==&#39;S&#39;&amp;&amp;b==&#39;J&#39;||d==&#39;S&#39;&amp;&amp;a==&#39;J&#39;&amp;&amp;b==&#39;S&#39;||d==&#39;J&#39;&amp;&amp;a==&#39;B&#39;&amp;&amp;b==&#39;J&#39;||d==&#39;J&#39;&amp;&amp;a==&#39;J&#39;&amp;&amp;b==&#39;B&#39;||d==&#39;B&#39;&amp;&amp;a==&#39;B&#39;&amp;&amp;b==&#39;S&#39;||d==&#39;B&#39;&amp;&amp;a==&#39;S&#39;&amp;&amp;b==&#39;B&#39;){ printf(&quot;lyrnb&quot;); }else{ printf(&quot;pmznb&quot;); } } tags: game *600 C-秘密的议会 题目链接 签到成功，这是你的签到奖励.jpg #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; void solve(){ char ch[110]; scanf(&quot;%s&quot;,ch); int n=strlen(ch); int cnt1=0;int cnt2=0; for(int i=0;i&lt;n;i++){ if(ch[i]==&#39;Y&#39;||ch[i]==&#39;y&#39;){ cnt1++; }else if(ch[i]==&#39;N&#39;||ch[i]==&#39;n&#39;){ cnt2++; } } if(cnt1&gt;=n/2){ printf(&quot;pmznb\\n&quot;); }else if(cnt2&gt;=n/2){ printf(&quot;lyrnb\\n&quot;); }else printf(&quot;wsdd\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t); while(t--) solve(); } tags: *600 D-城市的税金 题目链接 按题意模拟即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll a[maxn]; int n,m; ll fun(ll x){ return x*251%996*404*123; } map&lt;ll,int&gt;mp; int main(){ scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;a[i]); } while(m--){ ll op,b,c; scanf(&quot;%lld%lld%lld&quot;,&amp;op,&amp;b,&amp;c); if(op==1){ for(int i=b;i&lt;=c;i++){ a[i]=fun(a[i]); } }else{ mp.clear();int ans=0; for(int i=b;i&lt;=c;i++){ mp[a[i]]++; ans=max(ans,mp[a[i]]); } printf(&quot;%d\\n&quot;,ans); } } } tags: implementation data strcutres *700 E-缺席的神官 题目链接 基础贪心，将工作日之间的间隔加入优先队列，取前k个即可。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll a[maxn]; int n,m,k; int main(){ scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k); for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); int sum=a[n]-a[1]+1; priority_queue&lt;int&gt;q; for(int i=1;i&lt;n;i++){ q.push(a[i+1]-a[i]-1); } k--; while(k--){ sum-=q.top();q.pop(); } printf(&quot;%d\\n&quot;,sum); } tags: greedy *1000 F-失踪的玫瑰 题目链接 待补 tags:math *2200 G-虚数的纸牌 题目链接 sb模拟题，按题意模拟即可 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; int f1(int x){ if(x==4) return 6; if(x==3) return 3; if(x==2) return 1; } int f2(int x){ if(x==4) return 4; return 1; } char ch[20]; int cnt[15]; void solve(){ scanf(&quot;%s&quot;,ch); memset(cnt,0,sizeof(cnt)); int n=strlen(ch); for(int i=0;i&lt;n;i++){ if(ch[i]&gt;=&#39;3&#39;&amp;&amp;ch[i]&lt;=&#39;9&#39;){ cnt[ch[i]-&#39;3&#39;]++; }else if(ch[i]==&#39;0&#39;) cnt[7]++; else if(ch[i]==&#39;A&#39;) cnt[11]++; else if(ch[i]==&#39;2&#39;) cnt[12]++; else if(ch[i]==&#39;J&#39;) cnt[8]++; else if(ch[i]==&#39;Q&#39;) cnt[9]++; else if(ch[i]==&#39;K&#39;) cnt[10]++; } int ans=17; for(int i=0;i&lt;=12;i++){ if(cnt[i]&gt;=2){ ans+=f1(cnt[i]); }if(cnt[i]&gt;=3){ ans+=f2(cnt[i])*(17-cnt[i]); int res=0; for(int j=0;j&lt;=12;j++){ if(i==j) continue; if(cnt[j]&gt;=2){ res+=f1(cnt[j]); } } ans+=res*f2(cnt[i]); }if(cnt[i]==4){ ans++; } } for(int i=0;i&lt;=8;i++){ if(cnt[i]&amp;&amp;cnt[i+1]&amp;&amp;cnt[i+2]&amp;&amp;cnt[i+3]&amp;&amp;cnt[i+4]){ ans+=cnt[i]*cnt[i+1]*cnt[i+2]*cnt[i+3]*cnt[i+4]; } } printf(&quot;%d\\n&quot;,ans); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } tags: implementation *1000 H-绵羊的硬币 题目链接 打个表 天才wz嘴了正解 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll fib[110]; void solve(){ ll n;scanf(&quot;%lld&quot;,&amp;n); ll now=1;int cnt=0; for(int i=0;i&lt;=60;i++){ if(now&gt;n){ break; } now*=2;cnt++; } printf(&quot;%lld\\n&quot;,fib[cnt]); } int main(){ fib[1]=1;fib[2]=1; for(int i=3;i&lt;=100;i++){ fib[i]=fib[i-1]+fib[i-2]; }int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } tags: math,brute force,*1300 I-迷途的怪物 题目链接 找规律，当n为奇数时答案为1，n为偶数时答案为p-1;就是这么简单 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; ll p;char n[1000010]; void solve(){ scanf(&quot;%lld%s&quot;,&amp;p,n); int len=strlen(n); int ok=n[len-1]-&#39;0&#39;; if(ok%2==0){ printf(&quot;1\\n&quot;); }else{ printf(&quot;%lld\\n&quot;,p-1); } } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--) solve(); } tags: math,brute force,*1500 J-简单的数学 题目链接 简单数学题（不是 只要你认真求导 发现当x=1代进去 能消掉一大片233. 代码又是傻逼几行 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; void solve(){ ll n;scanf(&quot;%lld&quot;,&amp;n); if(n%2==0) printf(&quot;-%lld\\n&quot;,n*(n+1)); else printf(&quot;%lld\\n&quot;,n*(n+1)); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--){ solve(); } } tags: math,*1300 K-消亡的质数 题目链接 被天才wz嘲笑了两天 自闭了 傻逼题 但我更sb #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; void solve(){ ll n;scanf(&quot;%lld&quot;,&amp;n); n--;if(n%3){ printf(&quot;NO\\n&quot;);return ; } n/=3;ll p=sqrt(n);if(p*(p+1)==n) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); } int main(){ int t;scanf(&quot;%d&quot;,&amp;t);while(t--){ solve(); } } tags: math,*-1 L-危险的台阶 待补 tags:math, *2500 M-破碎的愿望 题目链接 为什么，明明是我最爱字符串题，为什么会变成这样。。。 写了1w年 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=2e5+50; char ch[40]; int main(){ int n;ll k;scanf(&quot;%d%lld&quot;,&amp;n,&amp;k); scanf(&quot;%s&quot;,ch); ll x1=k/n;ll x2=k%n; if(x2) x1++; if(x1%2==0) reverse(ch,ch+n); x2=(k-1)%n; printf(&quot;%c&quot;,ch[x2]); } tags:strings *500","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces图论刷题之路 2-1245D. Shichikuji and Power Grid","slug":"graph2","date":"2019-11-09T07:49:22.000Z","updated":"2019-11-09T07:57:33.705Z","comments":true,"path":"2019/11/09/graph2/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/09/graph2/","excerpt":"一道看似很牛逼实际上很sb的最小生成树，绝了。","text":"一道看似很牛逼实际上很sb的最小生成树，绝了。 先对原图建立一个完全图，边权如题所示，再建立一个虚拟源点，每个点和源点都连一条边，权值为建造这个点为发电站的值。然后跑最小生成树。。。艹，这也太sb了。 时间复杂度 O(N2)； 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxe=4e6+50; const int maxn=2050; struct node{ int s,t; ll val; }edge[maxe],ans0[maxn],ans1[maxn]; int bel[maxn]; int vis[maxn]; ll x[maxn],y[maxn],cost[maxn]; int cnt,n,res0,res1; int cmp(node a,node b){ return a.val&lt;b.val; } int find(int x){ if(bel[x]!=x){ return bel[x]=find(bel[x]); } return x; } void merge(int x,int y){ int fx=find(x); int fy=find(y); if(fx!=fy){ bel[max(fx,fy)]=min(fx,fy); } } void init(){ for(int i=0;i&lt;=n;i++){ vis[i]=0; bel[i]=i; } cnt=0;res0=0;res1=0; } void add(int a,int b,ll c){ edge[cnt].s=a; edge[cnt].t=b; edge[cnt++].val=c; } ll kruskal(){ ll ans=0; int count=0; sort(edge,edge+cnt,cmp); for(int i=0;i&lt;cnt;i++){ if(find(edge[i].s)!=find(edge[i].t)){ ans+=edge[i].val; merge(edge[i].s,edge[i].t); count++; if(edge[i].s==0||edge[i].t==0) ans0[++res0]=edge[i]; else ans1[++res1]=edge[i]; } if(count==n) break; } return ans; } int main(){ scanf(&quot;%d&quot;,&amp;n); init(); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld%lld&quot;,&amp;x[i],&amp;y[i]); }for(int i=1;i&lt;=n;i++){ ll x;scanf(&quot;%lld&quot;,&amp;x); add(0,i,x); }for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;cost[i]); for(int j=1;j&lt;i;j++){ ll c=abs(x[i]-x[j])+abs(y[i]-y[j]); c*=(cost[i]+cost[j]); add(i,j,c); } } printf(&quot;%lld\\n&quot;,kruskal()); printf(&quot;%d\\n&quot;,res0); for(int i=1;i&lt;=res0;i++){ printf(&quot;%d &quot;,max(ans0[i].s,ans0[i].t)); }printf(&quot;\\n%d\\n&quot;,res1); for(int i=1;i&lt;=res1;i++){ printf(&quot;%d %d\\n&quot;,ans1[i].s,ans1[i].t); } }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CodeForces图论刷题之路 1-1243D. 0-1 MST","slug":"CFGraphs","date":"2019-11-09T07:36:01.000Z","updated":"2019-11-09T07:46:04.674Z","comments":true,"path":"2019/11/09/CFGraphs/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/09/CFGraphs/","excerpt":"发现自己图论菜的一 所以开始疯狂刷图论题。这是一道看似最小生成树实则是求补图连通块个数的题。","text":"发现自己图论菜的一 所以开始疯狂刷图论题。这是一道看似最小生成树实则是求补图连通块个数的题。 如何求连通块的个数：对每一个节点，如果他没有被讨论过，即vis[i]=0,则对它进行讨论：将那些剩下未讨论的节点逐个遍历，若他们之间没有权值为1的边相连，则说明在补图中他们是连通的，于是将他们归为一个集合，并从未讨论的集合中删除，这样从1到n逐个遍历。复杂度为（n+m）logn，因为看似是先for一遍再在每个i中再for一遍，可由于边也只有1e5条，所以均摊下来复杂度是成立的。 其中 未讨论的集合我放到了set中，已经讨论过就打上vis标记并从v中删除，每一次讨论用dfs将之后能够加入到这个连通块中的点一并加入，这样就不用并查集最后再遍历一遍数个数了。 QAQ。。。。 时间：140ms 代码： #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=1e5+50; const int INF = 1e9; set&lt;int&gt;g[maxn]; set&lt;int&gt;v; int vis[maxn]; void dfs(int x){ vis[x]=1; vector&lt;int&gt;tmp; for(int i:v){ if(!g[x].count(i)){ tmp.push_back(i); } } for(int i:tmp){ v.erase(i); } for(int i:tmp){ dfs(i); } } int main(){ int n,m; scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=m;i++){ int a,b; scanf(&quot;%d%d&quot;,&amp;a,&amp;b); g[a].insert(b);g[b].insert(a); } for(int i=1;i&lt;=n;i++){ v.insert(i); } //memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++) vis[i]=0;int ans=0; for(int i=1;i&lt;=n;i++){ if(!vis[i]){ ans++; v.erase(i); dfs(i); } } printf(&quot;%d\\n&quot;,ans-1); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"CF1256B-Minimize the Permutation题解","slug":"CF1256b-Minimize the Permutation题解","date":"2019-11-05T13:11:55.000Z","updated":"2019-11-05T13:23:46.967Z","comments":true,"path":"2019/11/05/CF1256b-Minimize the Permutation题解/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/05/CF1256b-Minimize%20the%20Permutation%E9%A2%98%E8%A7%A3/","excerpt":"这道题。。比赛时候甚至写炸了 555 我太菜了","text":"这道题。。比赛时候甚至写炸了 555 我太菜了 题解：因为每个交换只能用一次 而且数据范围贼小 直接n2暴力即可 方法：从1枚举到N 当枚举到一个i时 贪心地把i往前移动，如果当前所在位置的移动机会已经用掉或者前面一个数比当前的数要小 则停止移动 n2是因为我懒得写VIS数组了。。直接暴力找 on的解法也很容易写 上代码 n2 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=110+50; typedef long long ll; int a[maxn]; int vis[maxn]; int main(){ int t,n; scanf(&quot;%d&quot;,&amp;t); while(t--){ memset(vis,0,sizeof(vis)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=1;i&lt;=n;i++){ int now; for(int j=1;j&lt;=n;j++){ if(a[j]==i){ now=j;break; } } for(int j=now;j&gt;=2;j--){ if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1]){ swap(a[j],a[j-1]); vis[j-1]=1; }else{ break; } } } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); } } on 加了个pos数组存储位置 实时更新 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn=110+50; typedef long long ll; int a[maxn]; int vis[maxn]; int pos[maxn]; int main(){ int t,n; scanf(&quot;%d&quot;,&amp;t); while(t--){ memset(vis,0,sizeof(vis)); scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;i++){ scanf(&quot;%d&quot;,&amp;a[i]); pos[a[i]]=i; } for(int i=1;i&lt;=n;i++){ int now=pos[i]; for(int j=now;j&gt;=2;j--){ if(!vis[j-1]&amp;&amp;a[j]&lt;a[j-1]){ swap(pos[a[j]],pos[a[j-1]]); swap(a[j],a[j-1]); vis[j-1]=1; }else{ break; } } } for(int i=1;i&lt;=n;i++) printf(&quot;%d &quot;,a[i]); printf(&quot;\\n&quot;); } } 。。多练吧QAQ","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"LuoGuP1470【最长前缀LongestPrefix】","slug":"LuoGuP1470【最长前缀LongestPrefix】","date":"2019-11-04T09:54:20.000Z","updated":"2019-11-05T04:11:11.060Z","comments":true,"path":"2019/11/04/LuoGuP1470【最长前缀LongestPrefix】/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/LuoGuP1470%E3%80%90%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80LongestPrefix%E3%80%91/","excerpt":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。","text":"（反正题解没人看 就提供个思路吧） Trie+DFS 每搜到一个节点看它是不是一个单词的终点，是就加一个搜索路径，不是就按照Trie的Find()模板进行DFS. 优化：记得加vis数组进行记忆化搜索，不然会有重复情况会TLE。 上代码 #include &lt;iostream&gt; #include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;math.h&gt; #include&lt;queue&gt; #include&lt;vector&gt; #include&lt;map&gt; #include&lt;algorithm&gt; using namespace std; typedef long long ll; typedef unsigned long long ull; const int maxn=5050; const int INF = 0x3f3f3f3f; int tree[maxn][30]; bool vis[2020][200020]; int ed[maxn]; char que[200020]; char ch[20]; int n,cnt,Len; int ans=0; int newnode(){ for(int i=0;i&lt;=26;i++){ tree[cnt][i]=-1; } ed[cnt]=0; return cnt++; } void init(){ cnt=0; newnode(); } void insert(){ int len=strlen(ch); int root=0; for(int i=0;i&lt;len;i++){ int x=ch[i]-&#39;A&#39;; if(tree[root][x]&lt;=0){ tree[root][x]=newnode(); } root=tree[root][x]; } ed[root]=1; } void dfs(int pos,int len){ if(vis[pos][len]) return; vis[pos][len]=1; int x=que[len]-&#39;A&#39;; if(ed[pos]){ ans=max(ans,len); } if(len==Len){ return; } if(tree[pos][x]!=-1){ dfs(tree[pos][x],len+1); }if(ed[pos]){ dfs(0,len); } } int main(){ init(); while(scanf(&quot;%s&quot;,ch)&amp;&amp;strcmp(ch,&quot;.&quot;)){ insert(); } Len=0; while(scanf(&quot;%s&quot;,que+Len)!=EOF){ Len=strlen(que); } dfs(0,0); printf(&quot;%d\\n&quot;,ans); }","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"To Do List","slug":"ToDoList","date":"2019-11-04T09:51:39.000Z","updated":"2020-01-01T09:23:31.633Z","comments":true,"path":"2019/11/04/ToDoList/","link":"","permalink":"https//:ForgGYLH.github.io/2019/11/04/ToDoList/","excerpt":"断断续续搞了两三天，终于是完工了，可以开始写博客了。","text":"断断续续搞了两三天，终于是完工了，可以开始写博客了。 第一篇博客 总要定一点远大的理想 那下面就是To-Do-List：1.染个头发+买个显示器2.上个紫名3.学点图论 搞点数论字符串4.经常更博5.一等奖学金6.校赛天梯赛一血前耻7.拿到参加省赛的机会8.拿到尽可能多的参赛机会 9.CCPC ICPC Golden medal暂时先列这么多….有想法再补 FrogG冲冲冲!想一下接下来要学习和巩固的算法 图论：最短路dij 网络流相关 数据结构：线段树 平衡树 DP 搜索相关 杂项：差分约束 2-sat 位运算相关 分治 数论相关。。。 字符串：后缀数组 定个小目标 扫荡1900分以下的题","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"https//:ForgGYLH.github.io/tags/%E9%9A%8F%E7%AC%94/"}]}]}