{"meta":{"title":"我们都有光明的前途","subtitle":"想拿金牌想上红名","description":null,"author":"FlaMingo's Training Record.","url":"https//:ForgGYLH.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-10-31T10:43:52.000Z","updated":"2019-11-03T12:45:59.743Z","comments":true,"path":"tags/index.html","permalink":"https//:ForgGYLH.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-31T10:44:01.000Z","updated":"2019-11-03T12:44:40.135Z","comments":true,"path":"categories/index.html","permalink":"https//:ForgGYLH.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"FlaminGo","slug":"FlaMingo","date":"9998-12-31T16:00:00.000Z","updated":"2020-07-21T11:33:43.277Z","comments":true,"path":"9999/01/01/FlaMingo/","link":"","permalink":"https//:ForgGYLH.github.io/9999/01/01/FlaMingo/","excerpt":"","text":"成员 $\\color{purple}{KafuuChino}$","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"杭电多校第一场","slug":"杭电多校1","date":"2020-07-20T16:00:00.000Z","updated":"2020-07-21T11:17:21.268Z","comments":true,"path":"2020/07/21/杭电多校1/","link":"","permalink":"https//:ForgGYLH.github.io/2020/07/21/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A11/","excerpt":"Solved:3/12; Upsolved:3/12;","text":"Solved:3/12; Upsolved:3/12;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"牛客多校第四场","slug":"牛客多校4","date":"2020-07-19T16:00:00.000Z","updated":"2020-07-21T11:16:54.772Z","comments":true,"path":"2020/07/20/牛客多校4/","link":"","permalink":"https//:ForgGYLH.github.io/2020/07/20/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A14/","excerpt":"Solved:3/10; Upsolved:4/10;","text":"Solved:3/10; Upsolved:4/10;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"牛客多校第三场","slug":"牛客多校3","date":"2020-07-17T16:00:00.000Z","updated":"2020-07-21T11:16:33.694Z","comments":true,"path":"2020/07/18/牛客多校3/","link":"","permalink":"https//:ForgGYLH.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A13/","excerpt":"Solved:7/12; Upsolved:8/12;","text":"Solved:7/12; Upsolved:8/12;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"牛客多校第二场","slug":"牛客多校2","date":"2020-07-12T16:00:00.000Z","updated":"2020-07-15T09:25:31.517Z","comments":true,"path":"2020/07/13/牛客多校2/","link":"","permalink":"https//:ForgGYLH.github.io/2020/07/13/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A12/","excerpt":"Solved:3/11; Upsolved:8/11;","text":"Solved:3/11; Upsolved:8/11;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"牛客多校第一场","slug":"牛客多校1","date":"2020-07-11T16:00:00.000Z","updated":"2020-07-15T15:07:25.595Z","comments":true,"path":"2020/07/12/牛客多校1/","link":"","permalink":"https//:ForgGYLH.github.io/2020/07/12/%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A11/","excerpt":"Solved:2/10; Upsolved:6/10;","text":"Solved:2/10; Upsolved:6/10; A. B-Suffix ArrayWaiting for Solve….. 解题思路：​ B. Infinite Tree解题思路：​ 对于1到m的阶乘，求出包含它们以及它们LCA的虚树，具体实现过程中dfs序用dep深度代替，然后求LCA需要用到树状数组。建完虚树后就是简单的树形dp。 #include&lt;bits/stdc++.h&gt; using namespace std; typedef long long ll; const int maxn=5e5+50; int w[maxn],T[maxn],n; vector&lt;int&gt;pri[maxn],g[maxn]; int h[maxn],st[maxn]; ll dp[maxn],son[maxn],wsum; void add(int k,int v){for(;k&lt;=n;k+=k&amp;-k) T[k]+=v;} int qsum(int k){int ans=0;for(;k;k-=k&amp;-k) ans+=T[k];return ans;} void dfs1(int u,int f){ for(auto v:g[u]){ if(v==f) continue; dfs1(v,u);son[u]+=son[v]; }if(u&lt;=n) son[u]+=w[u]; }void dfs2(int u,int f){ for(auto v:g[u]){ if(v==f) continue; dp[v]=dp[u]+1ll*(h[v]-h[u])*(wsum-2ll*son[v]);dfs2(v,u); } }int cmp(int a,int b){ return a&gt;b; } int main(){ //freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin); for(int i=2;i&lt;=1e5;i++){ int a=i; for(int j=2;j*j&lt;=a;j++){ while(a%j==0){ a/=j;pri[i].push_back(j); } }if(a&gt;1) pri[i].push_back(a); sort(pri[i].begin(),pri[i].end(),cmp); }while(scanf(&quot;%d&quot;,&amp;n)!=EOF){ wsum=0,dp[1]=0; for(int i=1;i&lt;=2*n;i++) g[i].clear(),son[i]=0,T[i]=0; for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;w[i]),wsum+=w[i]; int top=0,cnt=n;st[++top]=1; for(int i=2;i&lt;=n;i++){ int lca=h[i-1]-qsum(pri[i][0]-1); if(lca!=h[st[top]]){ while(top&gt;1&amp;&amp;h[st[top-1]]&gt;=lca){ int x=st[top-1],y=st[top];top--; g[x].push_back(y);g[y].push_back(x); }if(top&gt;1&amp;&amp;h[st[top-1]]&lt;lca){ int x=st[top];h[++cnt]=lca; g[cnt].push_back(x);g[x].push_back(cnt); st[top]=cnt; } }st[++top]=i;h[i]=h[i-1]+pri[i].size(); for(int j=0;j&lt;pri[i].size();j++){ add(pri[i][j],1); } }while(top&gt;1){ int x=st[top-1],y=st[top];top--; g[x].push_back(y);g[y].push_back(x); }dfs1(1,0);for(int i=1;i&lt;=n;i++) dp[1]+=1ll*h[i]*w[i]; dfs2(1,0);ll ans=dp[1]; for(int i=2;i&lt;=cnt;i++){ ans=min(ans,dp[i]); }printf(&quot;%lld\\n&quot;,ans); } } C. Domino​ 给定约束条件$\\sum_{i=1}^n\\sum_{j=1}^nA_{i,j}x_ix_j\\leq1$，使得$\\sum_{i=1}^nb_ix_i$最小，求$(\\sum_{i=1}^nb_ix_i)^2$的值。（A，b已知，x未知，答案为分数形式对998244353取模） Waiting for Solve….. 解题思路： D. Quadratic Form大致题意：​ 给定约束条件$\\sum_{i=1}^n\\sum_{j=1}^nA_{i,j}x_ix_j\\leq1$，使得$\\sum_{i=1}^nb_ix_i$最小，求$(\\sum_{i=1}^nb_ix_i)^2$的值。（A，b已知，x未知，答案为分数形式对998244353取模） 解题思路：​ 不等式约束优化问题，用拉格朗日乘数法列出KKT方程求解，原问题可化简为求$B^TA^{-1}B$,求出A矩阵的逆矩阵即可。 #include&lt;bits/stdc++.h&gt; #define rd(a) scanf(&quot;%d&quot;,&amp;a) #define rep(i,a,b) for(int i=(a);i&lt;=(b);i++) #define rev(i,a,b) for(int i=(a);i&gt;=(b);i--) using namespace std; typedef long long ll; const int inf=1ll&lt;&lt;30; const int N=400+5; const int mod=998244353; ll qpow(ll a, int b){ ll res=1; for(;b;b&gt;&gt;=1,a=a*a%mod){ if(b&amp;1)res=res*a%mod; } return res; } ll A[N][N],b[N]; ll Gauss_Jordan(int n,int m) { ll r=1; for(int i=1; i&lt;=n; i++) { int row=i; for(; row&lt;=n; row++)if(A[row][i])break; if(row&gt;n)continue; if(row!=i) { for(int j=1; j&lt;=m; j++)swap(A[i][j],A[row][j]); r=(mod-r)%mod; } r=r*A[i][i]%mod; ll t=qpow(A[i][i],mod-2); for(int j=1; j&lt;=m; j++)A[i][j]=A[i][j]*t%mod; for(int j=1; j&lt;=n; j++) if(j!=i) { t=A[j][i]; for(int k=1; k&lt;=m; k++)A[j][k]=(A[j][k]-t*A[i][k]%mod+mod)%mod; } } return r; } int n; int main(){ while(~scanf(&quot;%d&quot;,&amp;n)){ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ scanf(&quot;%lld&quot;,&amp;A[i][j]); A[i][j]=(A[i][j]+mod)%mod; A[i][j+n]=i==j; } } Gauss_Jordan(n,n&lt;&lt;1); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;b[i]); b[i]=(b[i]+mod)%mod; } ll ans=0; for(int i=1;i&lt;=n;i++){ ll sum=0; for(int j=1;j&lt;=n;j++){ sum+=A[j][i+n]*b[j]%mod; sum%=mod; } ans+=sum*b[i]%mod; ans%=mod; } printf(&quot;%lld\\n&quot;,ans); } return 0; } E. Counting Spanning TreesWaiting for Solve….. 解题思路： F. Infinite String Comparision大致题意：​ 给定约束条件$\\sum_{i=1}^n\\sum_{j=1}^nA_{i,j}x_ix_j\\leq1$，使得$\\sum_{i=1}^nb_ix_i$最小，求$(\\sum_{i=1}^nb_ix_i)^2$的值。（A，b已知，x未知，答案为分数形式对998244353取模） 解题思路：​ 不等式约束优化问题，用拉格朗日乘数法列出KKT方程求解，原问题可化简为求$B^TA^{-1}B$,求出A矩阵的逆矩阵即可。 #include&lt;bits/stdc++.h&gt; #define rd(a) scanf(&quot;%d&quot;,&amp;a) #define rep(i,a,b) for(int i=(a);i&lt;=(b);i++) #define rev(i,a,b) for(int i=(a);i&gt;=(b);i--) using namespace std; typedef long long ll; const int inf=1ll&lt;&lt;30; const int N=400+5; const int mod=998244353; ll qpow(ll a, int b){ ll res=1; for(;b;b&gt;&gt;=1,a=a*a%mod){ if(b&amp;1)res=res*a%mod; } return res; } ll A[N][N],b[N]; ll Gauss_Jordan(int n,int m) { ll r=1; for(int i=1; i&lt;=n; i++) { int row=i; for(; row&lt;=n; row++)if(A[row][i])break; if(row&gt;n)continue; if(row!=i) { for(int j=1; j&lt;=m; j++)swap(A[i][j],A[row][j]); r=(mod-r)%mod; } r=r*A[i][i]%mod; ll t=qpow(A[i][i],mod-2); for(int j=1; j&lt;=m; j++)A[i][j]=A[i][j]*t%mod; for(int j=1; j&lt;=n; j++) if(j!=i) { t=A[j][i]; for(int k=1; k&lt;=m; k++)A[j][k]=(A[j][k]-t*A[i][k]%mod+mod)%mod; } } return r; } int n; int main(){ while(~scanf(&quot;%d&quot;,&amp;n)){ for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ scanf(&quot;%lld&quot;,&amp;A[i][j]); A[i][j]=(A[i][j]+mod)%mod; A[i][j+n]=i==j; } } Gauss_Jordan(n,n&lt;&lt;1); for(int i=1;i&lt;=n;i++){ scanf(&quot;%lld&quot;,&amp;b[i]); b[i]=(b[i]+mod)%mod; } ll ans=0; for(int i=1;i&lt;=n;i++){ ll sum=0; for(int j=1;j&lt;=n;j++){ sum+=A[j][i+n]*b[j]%mod; sum%=mod; } ans+=sum*b[i]%mod; ans%=mod; } printf(&quot;%lld\\n&quot;,ans); } return 0; } G. BaXianGuoHai,GeXianShenTongWaiting for Solve….. 解题思路： H. Minmum-cost Flow解题思路： I. 1 or 2解题思路： J. Easy Integration解题思路：","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https//:ForgGYLH.github.io/tags/%E9%A2%98%E8%A7%A3/"}]}]}